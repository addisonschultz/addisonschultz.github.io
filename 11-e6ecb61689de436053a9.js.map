{"version":3,"sources":["webpack:///./node_modules/framer-motion/node_modules/tslib/tslib.es6.js","webpack:///./node_modules/hey-listen/dist/hey-listen.es.js","webpack:///./node_modules/framesync/dist/framesync.es.js","webpack:///./node_modules/style-value-types/dist/style-value-types.es.js","webpack:///./node_modules/@popmotion/easing/dist/easing.es.js","webpack:///./node_modules/@popmotion/popcorn/dist/popcorn.es.js","webpack:///./node_modules/stylefire/dist/stylefire.es.js","webpack:///./node_modules/popmotion/node_modules/tslib/tslib.es6.js","webpack:///./node_modules/popmotion/dist/popmotion.es.js","webpack:///./node_modules/framer-motion/dist/framer-motion.es.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","warning","invariant","StepId","prevTime","onNextFrame","window","undefined","requestAnimationFrame","callback","timestamp","Date","now","timeToCall","Math","max","setTimeout","defaultElapsed","useDefaultElapsed","willRunNextFrame","framesync_es_isProcessing","framesync_es_frame","delta","stepsOrder","Read","Update","Render","PostRender","setWillRunNextFrame","willRun","framesync_es_a","reduce","acc","key","setRunNextFrame","processToRun","processToRunNextFrame","numThisFrame","isProcessing","cancelled","toKeepAlive","renderStep","step","WeakSet","cancel","process","indexOfCallback","add","splice","frame","_a","process_1","has","schedule","keepAlive","immediate","addToCurrentBuffer","buffer","delete","push","sync","startLoop","cancelSync","steps","processStep","stepId","processFrame","min","forEach","getFrameData","framesync_es","style_value_types_es_assign","style_value_types_es_clamp","v","sanitize","Number","toFixed","floatRegex","colorRegex","singleColorRegex","number","test","parse","parseFloat","transform","alpha","style_value_types_es_scale","default","createUnitType","unit","endsWith","split","degrees","percent","px","vh","vw","progressPercentage","clampRgbUnit","isRgba","red","isHsla","hue","splitColorValues","terms","value","values","valuesArray","substring","lastIndexOf","rgbUnit","round","isColorString","color","colorType","startsWith","rgba","green","blue","_b","alpha$$1","rgbaTemplate","hsla","saturation","lightness","hslaTemplate","hex","r","g","b","substr","parseInt","convertNumbersToZero","complex","isNaN","numValues","foundNumbers","match","foundColors","input","parsed","replace","map","createTransformer","prop","template","token","numColors","numNumbers","output","getAnimatableNone","target","parsedTarget","targetTransformer","reversed","easing","mirrored","createReversedEasing","createMirroredEasing","createExpoIn","power","pow","createBackIn","createAnticipateEasing","backEasing","linear","easeIn","easeOut","easeInOut","circIn","sin","acos","circOut","circInOut","backIn","backOut","backInOut","anticipate","bounceOut","p2","bounceIn","bounceInOut","NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","K_SPLINE_TABLE_SIZE","K_SAMPLE_STEP_SIZE","FLOAT_32_SUPPORTED","Float32Array","easing_es_a","a1","a2","easing_es_b","c","getSlope","calcBezier","cubicBezier","mX1","mY1","mX2","mY2","sampleValues","Array","getTForX","aX","dist","guessForT","initialSlope","intervalStart","currentSample","lastSample","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","abs","binarySubdivide","calcSampleValues","zeroPoint","x","y","z","isNum","curryRange","func","cv","clamp$1","isPoint","point","isPoint3D","distance1D","a","distance","xDelta","yDelta","zDelta","sqrt","popcorn_es_progress","from","to","toFromDifference","mix","progress","popcorn_es_assign","mixLinearColor","fromExpo","toExpo","colorTypes","getColorType","find","type","notAnimatable","color$$1","mixColor","fromColorType","toColorType","fromColor","toColor","blended","mixFunc","combineFunctions","pipe","transformers","_i","getMixer","origin","mixComplex","mixArray","slice","blendValue","fromThis","mixObject","analyse","numRGB","numHSL","originStats","targetStats","mixNumber","createMixers","ease","customMixer","mixers","mixerFactory","isArray","numMixers","mixer","easingFunction","interpolate","_c","clamp","inputLength","concat","reverse","interpolator","fastInterpolate","lastInputIndex","mixerIndex","foundMixerIndex","progressInRange","slowInterpolate","identity","springForce","alterDisplacement","constant","displacement","springModifiedDisplacement","velocityPerSecond","velocity","frameDuration","stylefire_es_assign","rangeSize","stylefire_es_rest","testElement","createStyler","onRead","onRender","uncachedValues","Set","useCache","props","state","changedValues","hasChanged","setValue","hasCSSVariable","currentValue","render","styler","get","forceRead","set","forceRender","CAMEL_CASE_PATTERN","camelToDash","str","toLowerCase","camelCache","Map","dashCache","prefixes","numPrefixes","isBrowser","document","setDashPrefix","prefixed","prefixer","asDashCase","cache","createElement","prefix","noPrefix","prefixedPropertyName","charAt","toUpperCase","style","testPrefix","setServerProperty","axes","transformProps","axesAcc","axesKey","transformPropDictionary","dict","isTransformProp","sortTransformProps","transformOriginProps","isTransformOriginProp","stylefire_es_int","valueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","translateX","translateY","translateZ","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","getValueType","getValueAsType","SCROLL_LEFT","SCROLL_TOP","scrollKeys","blacklist","translateAlias","isCustomTemplate","buildStyleProperty","enableHardwareAcceleration","styles","transformOrigin","transformKeys","isDashCase","transformIsDefault","hasTransform","hasTransformOrigin","valueType","valueAsType","transformString","transformHasZ","sort","numTransformKeys","trim","buildTransform","createStyleBuilder","cssStyler","options","element","preparseOutput","defaultValueType","domValue","getComputedStyle","getPropertyValue","buildStyles","numChangedValues","setProperty","camelCaseAttributes","svgAttrsTemplate","progressToPixels","unmeasured","calcOrigin","offset","buildSVGAttrs","dimensions","totalPathLength","cssBuilder","attrs","pathLength","_d","pathSpacing","_e","pathOffset","calculateSVGTransformOrigin","createAttrBuilder","svgStyler","getAttribute","buildAttrs","setAttribute","viewport","pageYOffset","pageXOffset","scrollTop","scrollLeft","scrollTo","WeakMap","createDOMStyler","node","HTMLElement","createCssStyler","SVGElement","getBBox","getBoundingClientRect","getDimensions","getSVGElementDimensions","tagName","isPath","getTotalLength","getStyler","stylefire_es","nodeOrSelector","querySelector","tslib_es6_assign","tslib_es6_rest","Observer","observer","_this","middleware","onComplete","isActive","update","updateObserver","complete","error","err","m","createObserver","observerCandidate","popmotion_es_Action","Action","create","start","isComplete","subscription","stop","init","observerProps","api","applyMiddleware","funcs","pipedUpdate","popmotion_es_action","unitTypes","findUnitType","createAction","action","createUnitAction","unitType","createMixerAction","createColorAction","createComplexAction","createVectorAction","typeTests","testNames","keys","isVectorProp","getVectorKeys","vectorKeys","testVectorProps","some","createVectorTests","testProp","getActionCreator","Boolean","isUnitProp","vectorDecay","timeConstant","_f","restDelta","modifyTarget","elapsed","amplitude","idealTarget","frameDelta","exp","isMoving","vectorSpring","stiffness","damping","_g","mass","_h","restSpeed","_j","initialVelocity","position","prevPosition","timeDelta","dampingRatio","angularFreq","envelope","expoDecay","cos","isBelowVelocityThreshold","isBelowDisplacementThreshold","popmotion_es_index","bounceStiffness","bounceDamping","activeAnimation","prev","current","isSpring","isLessThanMin","isMoreThanMax","isOutOfBounds","onUpdate","currentVelocity","isTravellingAwayFromBounds","startSpring","startAnimation","animation","next","vectorScrubber","reverseEase","seek","popmotion_es_clampProgress","tween","duration","flip","loop","yoyo","repeatDelay","_k","_l","flipCount","_m","yoyoCount","_o","loopCount","playhead","currentProgress","reverseAnimation","updateTween","startTimer","stopTimer","getElapsed","getProgress","pause","resume","newProgress","clampProgress$1","keyframes","easings","times","tweenProps","defaultEasings","defaultTimings","scrubbers","rangeLength","finalInputIndex","finalScrubberIndex","subs","scrub","interpolateScrubbers","listen","events","eventNames","eventName","addEventListener","removeEventListener","defaultPointerPos","clientX","clientY","pageX","pageY","eventToPoint","points","passive","capture","touches","numTouches","thisTouch","popmotion_es_point","popmotion_es_delay","timeToDelay","timeout","clearTimeout","__webpack_require__","d","__webpack_exports__","motion","useMotionValue","useTransform","isFloat","framer_motion_es_MotionValue","MotionValue","transformer","parent","lastUpdated","canTrackVelocity","updateAndNotify","updateSubscribers","notifySubscriber","children","setChild","renderSubscribers","postRender","scheduleVelocityCheck","subscriber","velocityCheck","child","addChild","config","removeChild","subscribeTo","subscriptions","updateSubscriber","onChange","onRenderRequest","attach","passiveEffect","getVelocity","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","clear","motionValue","opts","useConstant","ref","react","resolver","isMotionValue","framer_motion_es_session","syncRenderSession","isOpen","open","flush","updateStyler","MotionValuesMap","hasMounted","unsubscribers","bindValueToOutput","defaultValue","unsubscribeOnRender","unsubscribeOnChange","setOnUpdate","setTransformTemplate","transformTemplate","updateTransformTemplate","getTransformTemplate","mount","unmount","_value","unsubscribe","specialMotionValueProps","useMotionValues","motionValues","MountMotionValues","isStatic","Element","domStyler","resolveCurrent","resolvedValues","framer_motion_es_transformOriginProps","framer_motion_es_isTransformOriginProp","buildStyleAttr","styleProp","motionValueStyles","useMotionStyles","transformValues","prevMotionStyles","currentStyleKeys","thisStyle","isKeyframesTarget","resolveFinalValueInKeyframes","dimensionTypes","framer_motion_es_valueTypes","testValueType","getDimensionValueType","framer_motion_es_getValueType","underDampedSpring","overDampedSpring","linearTween","framer_motion_es_keyframes","defaultTransitions","just","easingDefinitionToFunction","definition","easing_es_namespaceObject","isEasingArray","isAnimatable","secondsToMilliseconds","seconds","transitions","spring","inertia","transitionOptionParser","getTransitionDefinition","transitionDefinition","delay","when","delayChildren","staggerChildren","staggerDirection","transition","isTransitionDefined","valueKey","transitionFactory","getDefaultTransition","valueTransitionDefinition","getAnimation","isOriginAnimatable","isTargetAnimatable","actionFactory","preprocessOptions","framer_motion_es_startAnimation","delay$1","animate","framer_motion_es_ValueAnimationControls","ValueAnimationControls","readValueFromSource","makeTargetAnimatable","variants","baseTarget","overrides","resolvedOverrides","activeOverrides","hasValue","setProps","setVariants","setDefaultTransition","defaultTransition","setValues","priority","transitionEnd","targetValue","checkForNewValues","newValueKeys","filter","numNewValues","resolveVariant","variant","custom","getHighestPriority","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","overrideTarget","remainingValues","onStart","applyVariantLabels","variantLabelList","animateVariantLabels","animateVariant","animationDefinition","transitionOverride","animatable","animations","valueTarget","allAnimations","all","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","last","first","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","controls","resetChildren","framer_motion_es_AnimationControls","AnimationControls","pendingAnimations","componentControls","subscribe","animations_1","MotionContext","static","isVariantLabel","isAnimationControls","useMotionContext","parentContext","initialState","initial","whileTap","whileHover","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","context","initialToApply","Infinity","useValueAnimationControls","subscribeToParentControls","parentControls","unmountProps","Point","checkShouldInheritVariant","inherit","createMotionComponent","getValueControlsConfig","loadFunctionalityComponents","renderComponent","externalRef","external","useExternalRef","exitProps","isExiting","onExitComplete","exit","applyExitProps","shouldInheritVariant","functionality","renderedComponent","Provider","svgElements","subtract","relativeTo","idOrElem","elem","localElem","getElementById","rect","scrollX","scrollY","MotionPluginContext","transformPagePoint","isViewportScrollBlocked","event","preventDefault","blockViewportScroll","unblockViewportScroll","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","useUnmountEffect","addDomEvent","handler","defaultPagePoint","pointFromMouse","wrapHandler","shouldFilterPrimaryPointer","listener","changedTouches","extractEventInfo","eventHandler","button","filterPrimaryPointer","isBrowser$1","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","name","addPointerEvent","usePointerEvent","useDomEvent","startDevicePoint","session","pointHistory","lastDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","lastMoveEvent","lastMoveEventInfo","pointerEventSubscription","handlers","removePointerEvents","getPanInfo","currentPoint","transformPoint","info","cancelPan","updatePoint","panStarted","startEvent","distancePastThreshold","onPointerMove","buttons","onPointerUp","initialInfo","removeOnPointerMove","removeOnPointerUp","isNodeOrChild","parentElement","framer_motion_es_order","getGesturePriority","gesture","createLock","lock","globalHorizontalLock","globalVerticalLock","getGlobalLock","drag","openHorizontal_1","openVertical_1","tapGesturePriority","hoverPriority","filterTouch","useGestures","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","openGestureLock","useTapGesture","onHoverStart","onHoverEnd","useHoverGesture","makeHookComponent","hook","gestureProps","Gestures","shouldRender","Component","innerRef","isRefObject","allowDefaultPointerDown","getBoundingBox","getCurrentOffset","calculateConstraintsFromDom","constraintsRef","draggableRef","parentBoundingBox","draggableBoundingBox","shouldDrag","direction","currentDirection","getConstraints","axis","applyConstraints","constraints","dragElastic","constrainedValue","applyOverdrag","bothAxis","useDrag","dragDirectionLock","dragPropagation","dragConstraints","dragMomentum","_dragValueX","_dragValueY","_dragTransitionControls","dragOriginX","dragOriginY","dragTransition","onDirectionLock","onDragStart","onDrag","onDragEnd","onDragTransitionEnd","constraintsNeedResolution","dragStatus","isDragging","hasDragged","onResize","defaultOriginX","defaultOriginY","openGlobalLock","prevConstraintsBox","scalePoint","constraintsBox","draggableBox","scaleAxisPoint","dimension","pointToScale","recordBoxInfo","top_1","applyConstraintsToPoint","axisPoint","convertPanToDrag","axisOrigin","cancelDrag","lockThreshold","getCurrentDirection","onDirectionLock_1","momentumAnimations","animateDragEnd","activeElement","blur","Drag","isCSSVariable","cssVariableRegex","maxDepth","getVariableValue","depth","exec","parseCSSVariable","fallback","resolved","BoundingBoxDimension","positionalKeys","isPositionalKey","hasPositionalKey","setAndResetVelocity","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","positionalValues","checkAndConvertChangedValueTypes","elementStyler","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","toType","fromType","numKeyframes","removedTransforms","removeNonTranslationalTransform","convertedTarget","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","convertChangedValueTypes","parseDomVariant","resolveCSSVariables","unitConversion","framer_motion_es_a","StepName","SyncLayoutContext","jobs","Prepare","jobsNeedProcessing","flushCallbackList","list","numJobs","flushAllJobs","prepare","read","createUseSyncEffect","stepName","layoutSync","defaultLayoutTransition","defaultPositionTransition","centerOf","framer_motion_es_offset","getLayout","measure","offsetLeft","offsetTop","offsetWidth","offsetHeight","boundingBox","readPositionStyle","isSizeKey","useLayoutAnimation","layoutTransition","positionOnly","isHTMLElement","compare","nextPosition","getLayoutType","prevCenter","nextCenter","calcDelta","isResolver","makeTransition","layoutKey","transformKey","visualOrigin","deltaKey","baseTransition","getDefaultLayoutTransition","offsetToApply","AnimatePropType","Layout","positionTransition","validMotionProps","isValidMotionProp","hasUpdated","prevLength","shallowCompare","targetWithoutTransition","mergeTransitionEnd","_a$1","framer_motion_es_b","resolveVariantLabels","unresolvedVariant","asDependencyList","join","hasVariantChanged","oldVariant","newVariant","AnimatePropComponents","Target","targetAndTransition","isInitialRender","prevValues","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","useAnimateProp","VariantLabel","targetVariants","parentAlreadyMounted","shouldAnimate","useVariants","AnimationSubscription","useAnimationGroupSubscription","isAnimationSubscription","animationProps","animatePropTypeTests","getAnimationComponent","animatePropType","buildSVGProps","functionalityComponents","numFunctionalityComponents","createDomMotionConfig","isDOM","isSVG","forwardProps","domProps","stripMotionProps","staticVisualStyles","activeComponents","Animation","Component_1","htmlMotionComponents","svgMotionComponents","framer_motion_es_getMixer","isCustomValueType","isTransformer","noop","customTransform","comparitor","args","useImmediate","argOffset","inputValue","inputRange","outputRange","framer_motion_es_transform"],"mappings":"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AAA3uB,CAAa0wC,EAAc3wC,EAAQ,CAAEoD,OAAWkS,EAAA,CAAUzN,SAAAuwB,WAAA+K,SAAAxU,MAGpG,OAAA8hB,GAEAnW,uBAAA,SAAA3L,EAAA9mB,GACA,OACAA,SACA0sB,oBAAA,SAAAnxB,GACA,OAA2Bie,GAAMsN,EAAA3H,SAAAjR,IAAA3S,IAKjCoxB,qBAAA0V,GAAAriC,EAAA8mB,MAMA,IAAAiiB,GA7lEA,CACA,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,MACA,WA2+DA1tC,OAAA,SAAAC,EAAA+/B,GACA,IAAA5V,EAAA4iB,GAAAhN,GAIA,OADA//B,EAAA+/B,GAAA7I,GAAA/M,GACAnqB,GACC,IACD0tC,GAAAxV,GAAAn4B,OAAA,SAAAC,EAAA+/B,GAIA,OADA//B,EAAA+/B,GAAA7I,GAAA6V,GAAAhN,IACA//B,GACC,IAoBD6oB,GAAahsB,EAAQ,CAAE61B,OAAA,SAAAqN,GACvB,OAAA7I,GAAA6V,GAAAhN,MACO0N,GAAAC,IAgBP,IAGIC,GAAQ,SAAAlrC,GAAiB,OAH7B,SAAAA,GACA,uBAAAA,KAAA4K,IAE6BugC,CAAAnrC,KAAA4K,SAAA9O,GAgB7B,IAAAsvC,GAAA,SAAAprC,GACA,yBAAAA,GAEAqrC,GAAA,SAAArrC,GAAyB,OAAAA,GACzB,SAAAsmB,GAAAK,EAAA2kB,EAAA5gC,EAAA2N,GACA,IAAArW,EAAgB3H,OAAA2uB,EAAA,OAAA3uB,CAAM,MACtBkxC,EAAA,CAAA5kB,GACAD,EAAA2kB,GACA,GAAAD,GAAAE,GACA5kB,EAAA4kB,OAEA,GAAApjC,MAAAoF,QAAA5C,GAAA,CACA,IAAAD,EAAA6gC,EACA5kB,EA5BA,WAEA,IADA,IAAA8kB,EAAA,GACAt/B,EAAA,EAAoBA,EAAAvR,UAAAC,OAAuBsR,IAC3Cs/B,EAAAt/B,GAAAvR,UAAAuR,GAEA,IAAAu/B,GAAAvjC,MAAAoF,QAAAk+B,EAAA,IACAE,EAAAD,EAAA,KACAE,EAAAH,EAAA,EAAAE,GACAE,EAAAJ,EAAA,EAAAE,GACAG,EAAAL,EAAA,EAAAE,GACArzB,EAAAmzB,EAAA,EAAAE,GACA19B,EAAuBN,GAAWk+B,EAAAC,EAA0BzxC,EAAQ,CAAEoT,MAAQ09B,GAAQW,EAAA,KAAkBxzB,IACxG,OAAAozB,EAAAz9B,EAAA29B,GAAA39B,EAgBsB89B,CAASrhC,EAAAC,EAAA2N,GAC/BkzB,EAAA,CAAA5kB,EAAAlc,EAAA89B,KAAA,KAAA79B,EAAA69B,KAAA,MAEA,OAAWluC,OAAA2uB,EAAA,QAAA3uB,CAAO,WAIlB,OAHA2H,EAAAof,SACApf,EAAAof,QAAAsH,UACA1mB,EAAAof,QAAAuF,EAAAc,SAAA,CAAyCf,gBACzC1kB,EAAAof,SACKmqB,GAgGL3iB,GAAA,GACAA,GAAA,GACAA,GAAA,GACAA,GAAA","file":"11-e6ecb61689de436053a9.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\nexport { invariant, warning };\n","import { invariant } from 'hey-listen';\n\nvar prevTime = 0;\r\nvar onNextFrame = typeof window !== 'undefined' && window.requestAnimationFrame !== undefined\r\n    ? function (callback) { return window.requestAnimationFrame(callback); }\r\n    : function (callback) {\r\n        var timestamp = Date.now();\r\n        var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));\r\n        prevTime = timestamp + timeToCall;\r\n        setTimeout(function () { return callback(prevTime); }, timeToCall);\r\n    };\n\nvar createStep = (function (setRunNextFrame) {\r\n    var processToRun = [];\r\n    var processToRunNextFrame = [];\r\n    var numThisFrame = 0;\r\n    var isProcessing = false;\r\n    var i = 0;\r\n    var cancelled = new WeakSet();\r\n    var toKeepAlive = new WeakSet();\r\n    var renderStep = {\r\n        cancel: function (process) {\r\n            var indexOfCallback = processToRunNextFrame.indexOf(process);\r\n            cancelled.add(process);\r\n            if (indexOfCallback !== -1) {\r\n                processToRunNextFrame.splice(indexOfCallback, 1);\r\n            }\r\n        },\r\n        process: function (frame) {\r\n            var _a;\r\n            isProcessing = true;\r\n            _a = [\r\n                processToRunNextFrame,\r\n                processToRun\r\n            ], processToRun = _a[0], processToRunNextFrame = _a[1];\r\n            processToRunNextFrame.length = 0;\r\n            numThisFrame = processToRun.length;\r\n            if (numThisFrame) {\r\n                var process_1;\r\n                for (i = 0; i < numThisFrame; i++) {\r\n                    process_1 = processToRun[i];\r\n                    process_1(frame);\r\n                    if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {\r\n                        renderStep.schedule(process_1);\r\n                        setRunNextFrame(true);\r\n                    }\r\n                }\r\n            }\r\n            isProcessing = false;\r\n        },\r\n        schedule: function (process, keepAlive, immediate) {\r\n            if (keepAlive === void 0) { keepAlive = false; }\r\n            if (immediate === void 0) { immediate = false; }\r\n            invariant(typeof process === 'function', 'Argument must be a function');\r\n            var addToCurrentBuffer = immediate && isProcessing;\r\n            var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;\r\n            cancelled.delete(process);\r\n            if (keepAlive)\r\n                toKeepAlive.add(process);\r\n            if (buffer.indexOf(process) === -1) {\r\n                buffer.push(process);\r\n                if (addToCurrentBuffer)\r\n                    numThisFrame = processToRun.length;\r\n            }\r\n        }\r\n    };\r\n    return renderStep;\r\n});\n\nvar StepId;\r\n(function (StepId) {\r\n    StepId[\"Read\"] = \"read\";\r\n    StepId[\"Update\"] = \"update\";\r\n    StepId[\"Render\"] = \"render\";\r\n    StepId[\"PostRender\"] = \"postRender\";\r\n    StepId[\"FixedUpdate\"] = \"fixedUpdate\";\r\n})(StepId || (StepId = {}));\n\nvar maxElapsed = 40;\r\nvar defaultElapsed = (1 / 60) * 1000;\r\nvar useDefaultElapsed = true;\r\nvar willRunNextFrame = false;\r\nvar isProcessing = false;\r\nvar frame = {\r\n    delta: 0,\r\n    timestamp: 0\r\n};\r\nvar stepsOrder = [\r\n    StepId.Read,\r\n    StepId.Update,\r\n    StepId.Render,\r\n    StepId.PostRender\r\n];\r\nvar setWillRunNextFrame = function (willRun) { return (willRunNextFrame = willRun); };\r\nvar _a = stepsOrder.reduce(function (acc, key) {\r\n    var step = createStep(setWillRunNextFrame);\r\n    acc.sync[key] = function (process, keepAlive, immediate) {\r\n        if (keepAlive === void 0) { keepAlive = false; }\r\n        if (immediate === void 0) { immediate = false; }\r\n        if (!willRunNextFrame)\r\n            startLoop();\r\n        step.schedule(process, keepAlive, immediate);\r\n        return process;\r\n    };\r\n    acc.cancelSync[key] = function (process) { return step.cancel(process); };\r\n    acc.steps[key] = step;\r\n    return acc;\r\n}, {\r\n    steps: {},\r\n    sync: {},\r\n    cancelSync: {}\r\n}), steps = _a.steps, sync = _a.sync, cancelSync = _a.cancelSync;\r\nvar processStep = function (stepId) { return steps[stepId].process(frame); };\r\nvar processFrame = function (timestamp) {\r\n    willRunNextFrame = false;\r\n    frame.delta = useDefaultElapsed\r\n        ? defaultElapsed\r\n        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\r\n    if (!useDefaultElapsed)\r\n        defaultElapsed = frame.delta;\r\n    frame.timestamp = timestamp;\r\n    isProcessing = true;\r\n    stepsOrder.forEach(processStep);\r\n    isProcessing = false;\r\n    if (willRunNextFrame) {\r\n        useDefaultElapsed = false;\r\n        onNextFrame(processFrame);\r\n    }\r\n};\r\nvar startLoop = function () {\r\n    willRunNextFrame = true;\r\n    useDefaultElapsed = true;\r\n    if (!isProcessing)\r\n        onNextFrame(processFrame);\r\n};\r\nvar getFrameData = function () { return frame; };\n\nexport default sync;\nexport { cancelSync, getFrameData };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar clamp = function (min, max) { return function (v) {\r\n    return Math.max(Math.min(v, max), min);\r\n}; };\r\nvar sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };\r\nvar floatRegex = /(-)?(\\d[\\d\\.]*)/g;\r\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\r\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))$/i;\n\nvar number = {\r\n    test: function (v) { return typeof v === 'number'; },\r\n    parse: parseFloat,\r\n    transform: function (v) { return v; }\r\n};\r\nvar alpha = __assign({}, number, { transform: clamp(0, 1) });\r\nvar scale = __assign({}, number, { default: 1 });\n\nvar createUnitType = function (unit) { return ({\r\n    test: function (v) {\r\n        return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;\r\n    },\r\n    parse: parseFloat,\r\n    transform: function (v) { return \"\" + v + unit; }\r\n}); };\r\nvar degrees = createUnitType('deg');\r\nvar percent = createUnitType('%');\r\nvar px = createUnitType('px');\r\nvar vh = createUnitType('vh');\r\nvar vw = createUnitType('vw');\r\nvar progressPercentage = __assign({}, percent, { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });\n\nvar getValueFromFunctionString = function (value) {\r\n    return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));\r\n};\r\nvar clampRgbUnit = clamp(0, 255);\r\nvar isRgba = function (v) { return v.red !== undefined; };\r\nvar isHsla = function (v) { return v.hue !== undefined; };\r\nvar splitColorValues = function (terms) {\r\n    return function (v) {\r\n        if (typeof v !== 'string')\r\n            return v;\r\n        var values = {};\r\n        var valuesArray = getValueFromFunctionString(v).split(/,\\s*/);\r\n        for (var i = 0; i < 4; i++) {\r\n            values[terms[i]] =\r\n                valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;\r\n        }\r\n        return values;\r\n    };\r\n};\r\nvar rgbaTemplate = function (_a) {\r\n    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n    return \"rgba(\" + red + \", \" + green + \", \" + blue + \", \" + alpha$$1 + \")\";\r\n};\r\nvar hslaTemplate = function (_a) {\r\n    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n    return \"hsla(\" + hue + \", \" + saturation + \", \" + lightness + \", \" + alpha$$1 + \")\";\r\n};\r\nvar rgbUnit = __assign({}, number, { transform: function (v) { return Math.round(clampRgbUnit(v)); } });\r\nfunction isColorString(color, colorType) {\r\n    return color.startsWith(colorType) && singleColorRegex.test(color);\r\n}\r\nvar rgba = {\r\n    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'rgb') : isRgba(v)); },\r\n    parse: splitColorValues(['red', 'green', 'blue', 'alpha']),\r\n    transform: function (_a) {\r\n        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n        return rgbaTemplate({\r\n            red: rgbUnit.transform(red),\r\n            green: rgbUnit.transform(green),\r\n            blue: rgbUnit.transform(blue),\r\n            alpha: sanitize(alpha.transform(alpha$$1))\r\n        });\r\n    }\r\n};\r\nvar hsla = {\r\n    test: function (v) { return (typeof v === 'string' ? isColorString(v, 'hsl') : isHsla(v)); },\r\n    parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),\r\n    transform: function (_a) {\r\n        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;\r\n        return hslaTemplate({\r\n            hue: Math.round(hue),\r\n            saturation: percent.transform(sanitize(saturation)),\r\n            lightness: percent.transform(sanitize(lightness)),\r\n            alpha: sanitize(alpha.transform(alpha$$1))\r\n        });\r\n    }\r\n};\r\nvar hex = __assign({}, rgba, { test: function (v) { return typeof v === 'string' && isColorString(v, '#'); }, parse: function (v) {\r\n        var r = '';\r\n        var g = '';\r\n        var b = '';\r\n        if (v.length > 4) {\r\n            r = v.substr(1, 2);\r\n            g = v.substr(3, 2);\r\n            b = v.substr(5, 2);\r\n        }\r\n        else {\r\n            r = v.substr(1, 1);\r\n            g = v.substr(2, 1);\r\n            b = v.substr(3, 1);\r\n            r += r;\r\n            g += g;\r\n            b += b;\r\n        }\r\n        return {\r\n            red: parseInt(r, 16),\r\n            green: parseInt(g, 16),\r\n            blue: parseInt(b, 16),\r\n            alpha: 1\r\n        };\r\n    } });\r\nvar color = {\r\n    test: function (v) {\r\n        return (typeof v === 'string' && singleColorRegex.test(v)) ||\r\n            isRgba(v) ||\r\n            isHsla(v);\r\n    },\r\n    parse: function (v) {\r\n        if (rgba.test(v)) {\r\n            return rgba.parse(v);\r\n        }\r\n        else if (hsla.test(v)) {\r\n            return hsla.parse(v);\r\n        }\r\n        else if (hex.test(v)) {\r\n            return hex.parse(v);\r\n        }\r\n        return v;\r\n    },\r\n    transform: function (v) {\r\n        if (isRgba(v)) {\r\n            return rgba.transform(v);\r\n        }\r\n        else if (isHsla(v)) {\r\n            return hsla.transform(v);\r\n        }\r\n        return v;\r\n    }\r\n};\n\nvar COLOR_TOKEN = '${c}';\r\nvar NUMBER_TOKEN = '${n}';\r\nvar convertNumbersToZero = function (v) {\r\n    return typeof v === 'number' ? 0 : v;\r\n};\r\nvar complex = {\r\n    test: function (v) {\r\n        if (typeof v !== 'string' || !isNaN(v))\r\n            return false;\r\n        var numValues = 0;\r\n        var foundNumbers = v.match(floatRegex);\r\n        var foundColors = v.match(colorRegex);\r\n        if (foundNumbers)\r\n            numValues += foundNumbers.length;\r\n        if (foundColors)\r\n            numValues += foundColors.length;\r\n        return numValues > 0;\r\n    },\r\n    parse: function (v) {\r\n        var input = v;\r\n        var parsed = [];\r\n        var foundColors = input.match(colorRegex);\r\n        if (foundColors) {\r\n            input = input.replace(colorRegex, COLOR_TOKEN);\r\n            parsed.push.apply(parsed, foundColors.map(color.parse));\r\n        }\r\n        var foundNumbers = input.match(floatRegex);\r\n        if (foundNumbers) {\r\n            parsed.push.apply(parsed, foundNumbers.map(number.parse));\r\n        }\r\n        return parsed;\r\n    },\r\n    createTransformer: function (prop) {\r\n        var template = prop;\r\n        var token = 0;\r\n        var foundColors = prop.match(colorRegex);\r\n        var numColors = foundColors ? foundColors.length : 0;\r\n        if (foundColors) {\r\n            for (var i = 0; i < numColors; i++) {\r\n                template = template.replace(foundColors[i], COLOR_TOKEN);\r\n                token++;\r\n            }\r\n        }\r\n        var foundNumbers = template.match(floatRegex);\r\n        var numNumbers = foundNumbers ? foundNumbers.length : 0;\r\n        if (foundNumbers) {\r\n            for (var i = 0; i < numNumbers; i++) {\r\n                template = template.replace(foundNumbers[i], NUMBER_TOKEN);\r\n                token++;\r\n            }\r\n        }\r\n        return function (v) {\r\n            var output = template;\r\n            for (var i = 0; i < token; i++) {\r\n                output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\r\n            }\r\n            return output;\r\n        };\r\n    },\r\n    getAnimatableNone: function (target) {\r\n        var parsedTarget = complex.parse(target);\r\n        var targetTransformer = complex.createTransformer(target);\r\n        return targetTransformer(parsedTarget.map(convertNumbersToZero));\r\n    }\r\n};\n\nexport { number, scale, alpha, degrees, percent, progressPercentage, px, vw, vh, rgba, rgbUnit, hsla, hex, color, complex };\n","var DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar reversed = function (easing) {\n    return function (p) {\n        return 1 - easing(1 - p);\n    };\n};\nvar mirrored = function (easing) {\n    return function (p) {\n        return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n    };\n};\nvar createReversedEasing = reversed;\nvar createMirroredEasing = mirrored;\nvar createExpoIn = function (power) {\n    return function (p) {\n        return Math.pow(p, power);\n    };\n};\nvar createBackIn = function (power) {\n    return function (p) {\n        return p * p * ((power + 1) * p - power);\n    };\n};\nvar createAnticipateEasing = function (power) {\n    var backEasing = createBackIn(power);\n    return function (p) {\n        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n    };\n};\nvar linear = function (p) {\n    return p;\n};\nvar easeIn = /*#__PURE__*/createExpoIn(2);\nvar easeOut = /*#__PURE__*/reversed(easeIn);\nvar easeInOut = /*#__PURE__*/mirrored(easeIn);\nvar circIn = function (p) {\n    return 1 - Math.sin(Math.acos(p));\n};\nvar circOut = /*#__PURE__*/reversed(circIn);\nvar circInOut = /*#__PURE__*/mirrored(circOut);\nvar backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = /*#__PURE__*/reversed(backIn);\nvar backInOut = /*#__PURE__*/mirrored(backIn);\nvar anticipate = /*#__PURE__*/createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);\nvar BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nvar BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nvar BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nvar ca = 4356.0 / 361.0;\nvar cb = 35442.0 / 1805.0;\nvar cc = 16061.0 / 1805.0;\nvar bounceOut = function (p) {\n    var p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = function (p) {\n    return 1.0 - bounceOut(1.0 - p);\n};\nvar bounceInOut = function (p) {\n    return p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n};\nvar NEWTON_ITERATIONS = 8;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar K_SPLINE_TABLE_SIZE = 11;\nvar K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);\nvar FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';\nvar a = function (a1, a2) {\n    return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\nvar b = function (a1, a2) {\n    return 3.0 * a2 - 6.0 * a1;\n};\nvar c = function (a1) {\n    return 3.0 * a1;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);\n    var binarySubdivide = function (aX, aA, aB) {\n        var i = 0;\n        var currentX;\n        var currentT;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    };\n    var newtonRaphsonIterate = function (aX, aGuessT) {\n        var i = 0;\n        var currentSlope = 0;\n        var currentX;\n        for (; i < NEWTON_ITERATIONS; ++i) {\n            currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    };\n    var calcSampleValues = function () {\n        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {\n            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);\n        }\n    };\n    var getTForX = function (aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = K_SPLINE_TABLE_SIZE - 1;\n        var dist = 0.0;\n        var guessForT = 0.0;\n        var initialSlope = 0.0;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += K_SAMPLE_STEP_SIZE;\n        }\n        --currentSample;\n        dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;\n        initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);\n        }\n    };\n    calcSampleValues();\n    var resolver = function (aX) {\n        var returnValue;\n        if (mX1 === mY1 && mX2 === mY2) {\n            returnValue = aX;\n        } else if (aX === 0) {\n            returnValue = 0;\n        } else if (aX === 1) {\n            returnValue = 1;\n        } else {\n            returnValue = calcBezier(getTForX(aX), mY1, mY2);\n        }\n        return returnValue;\n    };\n    return resolver;\n}\n\nexport { reversed, mirrored, createReversedEasing, createMirroredEasing, createExpoIn, createBackIn, createAnticipateEasing, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, bounceOut, bounceIn, bounceInOut, cubicBezier };\n","import { hsla, rgba, hex, color, complex } from 'style-value-types';\nimport { invariant } from 'hey-listen';\nimport { getFrameData } from 'framesync';\nimport { createAnticipateEasing, createBackIn, createExpoIn, cubicBezier, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, reversed, mirrored } from '@popmotion/easing';\nexport { createAnticipateEasing, createBackIn, createExpoIn, cubicBezier, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, reversed, mirrored } from '@popmotion/easing';\n\nvar zeroPoint = {\r\n    x: 0,\r\n    y: 0,\r\n    z: 0\r\n};\r\nvar isNum = function (v) { return typeof v === 'number'; };\n\nvar radiansToDegrees = (function (radians) { return (radians * 180) / Math.PI; });\n\nvar angle = (function (a, b) {\r\n    if (b === void 0) { b = zeroPoint; }\r\n    return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\r\n});\n\nvar applyOffset = (function (from, to) {\r\n    var hasReceivedFrom = true;\r\n    if (to === undefined) {\r\n        to = from;\r\n        hasReceivedFrom = false;\r\n    }\r\n    return function (v) {\r\n        if (hasReceivedFrom) {\r\n            return v - from + to;\r\n        }\r\n        else {\r\n            from = v;\r\n            hasReceivedFrom = true;\r\n            return to;\r\n        }\r\n    };\r\n});\n\nvar curryRange = (function (func) { return function (min, max, v) { return (v !== undefined ? func(min, max, v) : function (cv) { return func(min, max, cv); }); }; });\n\nvar clamp = function (min, max, v) {\r\n    return Math.min(Math.max(v, min), max);\r\n};\r\nvar clamp$1 = curryRange(clamp);\n\nvar conditional = (function (check, apply) { return function (v) {\r\n    return check(v) ? apply(v) : v;\r\n}; });\n\nvar degreesToRadians = (function (degrees) { return (degrees * Math.PI) / 180; });\n\nvar isPoint = (function (point) {\r\n    return point.hasOwnProperty('x') && point.hasOwnProperty('y');\r\n});\n\nvar isPoint3D = (function (point) {\r\n    return isPoint(point) && point.hasOwnProperty('z');\r\n});\n\nvar distance1D = function (a, b) { return Math.abs(a - b); };\r\nvar distance = (function (a, b) {\r\n    if (b === void 0) { b = zeroPoint; }\r\n    if (isNum(a) && isNum(b)) {\r\n        return distance1D(a, b);\r\n    }\r\n    else if (isPoint(a) && isPoint(b)) {\r\n        var xDelta = distance1D(a.x, b.x);\r\n        var yDelta = distance1D(a.y, b.y);\r\n        var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\r\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\r\n    }\r\n    return 0;\r\n});\n\nvar progress = (function (from, to, value) {\r\n    var toFromDifference = to - from;\r\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\r\n});\n\nvar mix = (function (from, to, progress) {\r\n    return -progress * from + progress * to + from;\r\n});\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar mixLinearColor = function (from, to, v) {\r\n    var fromExpo = from * from;\r\n    var toExpo = to * to;\r\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\r\n};\r\nvar colorTypes = [hex, rgba, hsla];\r\nvar getColorType = function (v) {\r\n    return colorTypes.find(function (type) { return type.test(v); });\r\n};\r\nvar notAnimatable = function (color$$1) {\r\n    return \"'\" + color$$1 + \"' is not an animatable color. Use the equivalent color code instead.\";\r\n};\r\nvar mixColor = (function (from, to) {\r\n    var fromColorType = getColorType(from);\r\n    var toColorType = getColorType(to);\r\n    invariant(!!fromColorType, notAnimatable(from));\r\n    invariant(!!toColorType, notAnimatable(to));\r\n    invariant(fromColorType.transform === toColorType.transform, 'Both colors must be hex/RGBA, OR both must be HSLA.');\r\n    var fromColor = fromColorType.parse(from);\r\n    var toColor = toColorType.parse(to);\r\n    var blended = __assign({}, fromColor);\r\n    var mixFunc = fromColorType === hsla ? mix : mixLinearColor;\r\n    return function (v) {\r\n        for (var key in blended) {\r\n            if (key !== 'alpha') {\r\n                blended[key] = mixFunc(fromColor[key], toColor[key], v);\r\n            }\r\n        }\r\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\r\n        return fromColorType.transform(blended);\r\n    };\r\n});\n\nvar combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };\r\nvar pipe = (function () {\r\n    var transformers = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        transformers[_i] = arguments[_i];\r\n    }\r\n    return transformers.reduce(combineFunctions);\r\n});\n\nfunction getMixer(origin, target) {\r\n    if (isNum(origin)) {\r\n        return function (v) { return mix(origin, target, v); };\r\n    }\r\n    else if (color.test(origin)) {\r\n        return mixColor(origin, target);\r\n    }\r\n    else {\r\n        return mixComplex(origin, target);\r\n    }\r\n}\r\nvar mixArray = function (from, to) {\r\n    var output = from.slice();\r\n    var numValues = output.length;\r\n    var blendValue = from.map(function (fromThis, i) { return getMixer(fromThis, to[i]); });\r\n    return function (v) {\r\n        for (var i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nvar mixObject = function (origin, target) {\r\n    var output = __assign({}, origin, target);\r\n    var blendValue = {};\r\n    for (var key in output) {\r\n        if (origin[key] !== undefined && target[key] !== undefined) {\r\n            blendValue[key] = getMixer(origin[key], target[key]);\r\n        }\r\n    }\r\n    return function (v) {\r\n        for (var key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n};\r\nfunction analyse(value) {\r\n    var parsed = complex.parse(value);\r\n    var numValues = parsed.length;\r\n    var numNumbers = 0;\r\n    var numRGB = 0;\r\n    var numHSL = 0;\r\n    for (var i = 0; i < numValues; i++) {\r\n        if (numNumbers || typeof parsed[i] === 'number') {\r\n            numNumbers++;\r\n        }\r\n        else {\r\n            if (parsed[i].hue !== undefined) {\r\n                numHSL++;\r\n            }\r\n            else {\r\n                numRGB++;\r\n            }\r\n        }\r\n    }\r\n    return { parsed: parsed, numNumbers: numNumbers, numRGB: numRGB, numHSL: numHSL };\r\n}\r\nvar mixComplex = function (origin, target) {\r\n    var template = complex.createTransformer(target);\r\n    var originStats = analyse(origin);\r\n    var targetStats = analyse(target);\r\n    invariant(originStats.numHSL === targetStats.numHSL &&\r\n        originStats.numRGB === targetStats.numRGB &&\r\n        originStats.numNumbers >= targetStats.numNumbers, \"Complex values '\" + origin + \"' and '\" + target + \"' too different to mix. Ensure all colors are of the same type.\");\r\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\r\n};\n\nvar mixNumber = function (from, to) { return function (p) { return mix(from, to, p); }; };\r\nfunction detectMixerFactory(v) {\r\n    if (typeof v === 'number') {\r\n        return mixNumber;\r\n    }\r\n    else if (typeof v === 'string') {\r\n        if (color.test(v)) {\r\n            return mixColor;\r\n        }\r\n        else {\r\n            return mixComplex;\r\n        }\r\n    }\r\n    else if (Array.isArray(v)) {\r\n        return mixArray;\r\n    }\r\n    else if (typeof v === 'object') {\r\n        return mixObject;\r\n    }\r\n}\r\nfunction createMixers(output, ease, customMixer) {\r\n    var mixers = [];\r\n    var mixerFactory = customMixer || detectMixerFactory(output[0]);\r\n    var numMixers = output.length - 1;\r\n    for (var i = 0; i < numMixers; i++) {\r\n        var mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            var easingFunction = Array.isArray(ease) ? ease[i] : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\nfunction fastInterpolate(_a, _b) {\r\n    var from = _a[0], to = _a[1];\r\n    var mixer = _b[0];\r\n    return function (v) { return mixer(progress(from, to, v)); };\r\n}\r\nfunction slowInterpolate(input, mixers) {\r\n    var inputLength = input.length;\r\n    var lastInputIndex = inputLength - 1;\r\n    return function (v) {\r\n        var mixerIndex = 0;\r\n        var foundMixerIndex = false;\r\n        if (v <= input[0]) {\r\n            foundMixerIndex = true;\r\n        }\r\n        else if (v >= input[lastInputIndex]) {\r\n            mixerIndex = lastInputIndex - 1;\r\n            foundMixerIndex = true;\r\n        }\r\n        if (!foundMixerIndex) {\r\n            var i = 1;\r\n            for (; i < inputLength; i++) {\r\n                if (input[i] > v || i === lastInputIndex) {\r\n                    break;\r\n                }\r\n            }\r\n            mixerIndex = i - 1;\r\n        }\r\n        var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\r\n        return mixers[mixerIndex](progressInRange);\r\n    };\r\n}\r\nfunction interpolate(input, output, _a) {\r\n    var _b = _a === void 0 ? {} : _a, _c = _b.clamp, clamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;\r\n    var inputLength = input.length;\r\n    invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\r\n    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [].concat(input);\r\n        output = [].concat(output);\r\n        input.reverse();\r\n        output.reverse();\r\n    }\r\n    var mixers = createMixers(output, ease, mixer);\r\n    var interpolator = inputLength === 2\r\n        ? fastInterpolate(input, mixers)\r\n        : slowInterpolate(input, mixers);\r\n    return clamp\r\n        ? pipe(clamp$1(input[0], input[inputLength - 1]), interpolator)\r\n        : interpolator;\r\n}\n\nvar pointFromVector = (function (origin, angle, distance) {\r\n    angle = degreesToRadians(angle);\r\n    return {\r\n        x: distance * Math.cos(angle) + origin.x,\r\n        y: distance * Math.sin(angle) + origin.y\r\n    };\r\n});\n\nvar toDecimal = (function (num, precision) {\r\n    if (precision === void 0) { precision = 2; }\r\n    precision = Math.pow(10, precision);\r\n    return Math.round(num * precision) / precision;\r\n});\n\nvar smoothFrame = (function (prevValue, nextValue, duration, smoothing) {\r\n    if (smoothing === void 0) { smoothing = 0; }\r\n    return toDecimal(prevValue +\r\n        (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));\r\n});\n\nvar smooth = (function (strength) {\r\n    if (strength === void 0) { strength = 50; }\r\n    var previousValue = 0;\r\n    var lastUpdated = 0;\r\n    return function (v) {\r\n        var currentFramestamp = getFrameData().timestamp;\r\n        var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\r\n        var newValue = timeDelta\r\n            ? smoothFrame(previousValue, v, timeDelta, strength)\r\n            : previousValue;\r\n        lastUpdated = currentFramestamp;\r\n        previousValue = newValue;\r\n        return newValue;\r\n    };\r\n});\n\nvar snap = (function (points) {\r\n    if (typeof points === 'number') {\r\n        return function (v) { return Math.round(v / points) * points; };\r\n    }\r\n    else {\r\n        var i_1 = 0;\r\n        var numPoints_1 = points.length;\r\n        return function (v) {\r\n            var lastDistance = Math.abs(points[0] - v);\r\n            for (i_1 = 1; i_1 < numPoints_1; i_1++) {\r\n                var point = points[i_1];\r\n                var distance = Math.abs(point - v);\r\n                if (distance === 0)\r\n                    return point;\r\n                if (distance > lastDistance)\r\n                    return points[i_1 - 1];\r\n                if (i_1 === numPoints_1 - 1)\r\n                    return point;\r\n                lastDistance = distance;\r\n            }\r\n        };\r\n    }\r\n});\n\nvar identity = function (v) { return v; };\r\nvar springForce = function (alterDisplacement) {\r\n    if (alterDisplacement === void 0) { alterDisplacement = identity; }\r\n    return curryRange(function (constant, origin, v) {\r\n        var displacement = origin - v;\r\n        var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\r\n        return displacement <= 0\r\n            ? origin + springModifiedDisplacement\r\n            : origin - springModifiedDisplacement;\r\n    });\r\n};\r\nvar springForceLinear = springForce();\r\nvar springForceExpo = springForce(Math.sqrt);\n\nvar velocityPerFrame = (function (xps, frameDuration) {\r\n    return isNum(xps) ? xps / (1000 / frameDuration) : 0;\r\n});\n\nvar velocityPerSecond = (function (velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n});\n\nvar wrap = function (min, max, v) {\r\n    var rangeSize = max - min;\r\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\r\n};\r\nvar wrap$1 = curryRange(wrap);\n\nvar clampProgress = clamp$1(0, 1);\r\nvar steps = (function (steps, direction) {\r\n    if (direction === void 0) { direction = 'end'; }\r\n    return function (progress) {\r\n        progress =\r\n            direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\r\n        var expanded = progress * steps;\r\n        var rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\r\n        return clampProgress(rounded / steps);\r\n    };\r\n});\n\nexport { angle, applyOffset, clamp$1 as clamp, conditional, degreesToRadians, distance, interpolate, isPoint, isPoint3D, mix, mixArray, mixColor, mixComplex, mixObject, pipe, pointFromVector, progress, radiansToDegrees, smooth, smoothFrame, snap, springForce, springForceExpo, springForceLinear, steps, toDecimal, velocityPerFrame, velocityPerSecond, wrap$1 as wrap };\n","import sync from 'framesync';\nimport { alpha, color, degrees, scale, px, progressPercentage, number } from 'style-value-types';\nimport { invariant } from 'hey-listen';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    return t;\n}\n\nvar createStyler = function (_a) {\n    var onRead = _a.onRead,\n        onRender = _a.onRender,\n        _b = _a.uncachedValues,\n        uncachedValues = _b === void 0 ? new Set() : _b,\n        _c = _a.useCache,\n        useCache = _c === void 0 ? true : _c;\n    return function (_a) {\n        if (_a === void 0) {\n            _a = {};\n        }\n        var props = __rest(_a, []);\n        var state = {};\n        var changedValues = [];\n        var hasChanged = false;\n        function setValue(key, value) {\n            if (key.startsWith('--')) {\n                props.hasCSSVariable = true;\n            }\n            var currentValue = state[key];\n            state[key] = value;\n            if (state[key] === currentValue) return;\n            if (changedValues.indexOf(key) === -1) {\n                changedValues.push(key);\n            }\n            if (!hasChanged) {\n                hasChanged = true;\n                sync.render(styler.render);\n            }\n        }\n        var styler = {\n            get: function (key, forceRead) {\n                if (forceRead === void 0) {\n                    forceRead = false;\n                }\n                var useCached = !forceRead && useCache && !uncachedValues.has(key) && state[key] !== undefined;\n                return useCached ? state[key] : onRead(key, props);\n            },\n            set: function (values, value) {\n                if (typeof values === 'string') {\n                    setValue(values, value);\n                } else {\n                    for (var key in values) {\n                        setValue(key, values[key]);\n                    }\n                }\n                return this;\n            },\n            render: function (forceRender) {\n                if (forceRender === void 0) {\n                    forceRender = false;\n                }\n                if (hasChanged || forceRender === true) {\n                    onRender(state, props, changedValues);\n                    hasChanged = false;\n                    changedValues.length = 0;\n                }\n                return this;\n            }\n        };\n        return styler;\n    };\n};\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = '$1-$2';\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nvar camelCache = /*#__PURE__*/new Map();\nvar dashCache = /*#__PURE__*/new Map();\nvar prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];\nvar numPrefixes = prefixes.length;\nvar isBrowser = typeof document !== 'undefined';\nvar testElement;\nvar setDashPrefix = function (key, prefixed) {\n    return dashCache.set(key, camelToDash(prefixed));\n};\nvar testPrefix = function (key) {\n    testElement = testElement || document.createElement('div');\n    for (var i = 0; i < numPrefixes; i++) {\n        var prefix = prefixes[i];\n        var noPrefix = prefix === '';\n        var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);\n        if (prefixedPropertyName in testElement.style || noPrefix) {\n            camelCache.set(key, prefixedPropertyName);\n            setDashPrefix(key, \"\" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));\n        }\n    }\n};\nvar setServerProperty = function (key) {\n    return setDashPrefix(key, key);\n};\nvar prefixer = function (key, asDashCase) {\n    if (asDashCase === void 0) {\n        asDashCase = false;\n    }\n    var cache = asDashCase ? dashCache : camelCache;\n    if (!cache.has(key)) isBrowser ? testPrefix(key) : setServerProperty(key);\n    return cache.get(key) || key;\n};\n\nvar axes = ['', 'X', 'Y', 'Z'];\nvar order = ['translate', 'scale', 'rotate', 'skew', 'transformPerspective'];\nvar transformProps = /*#__PURE__*/order.reduce(function (acc, key) {\n    return axes.reduce(function (axesAcc, axesKey) {\n        axesAcc.push(key + axesKey);\n        return axesAcc;\n    }, acc);\n}, ['x', 'y', 'z']);\nvar transformPropDictionary = /*#__PURE__*/transformProps.reduce(function (dict, key) {\n    dict[key] = true;\n    return dict;\n}, {});\nfunction isTransformProp(key) {\n    return transformPropDictionary[key] === true;\n}\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\nvar transformOriginProps = /*#__PURE__*/new Set(['originX', 'originY', 'originZ']);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nvar int = /*#__PURE__*/__assign({}, number, { transform: Math.round });\nvar valueTypes = {\n    color: color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    zIndex: int,\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int\n};\nvar getValueType = function (key) {\n    return valueTypes[key];\n};\nvar getValueAsType = function (value, type) {\n    return type && typeof value === 'number' ? type.transform(value) : value;\n};\n\nvar SCROLL_LEFT = 'scrollLeft';\nvar SCROLL_TOP = 'scrollTop';\nvar scrollKeys = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP]);\n\nvar blacklist = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP, 'transform']);\nvar translateAlias = {\n    x: 'translateX',\n    y: 'translateY',\n    z: 'translateZ'\n};\nfunction isCustomTemplate(v) {\n    return typeof v === 'function';\n}\nfunction buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration) {\n    var transformString = '';\n    var transformHasZ = false;\n    transformKeys.sort(sortTransformProps);\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        transformHasZ = key === 'z' ? true : transformHasZ;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += 'translateZ(0)';\n    } else {\n        transformString = transformString.trim();\n    }\n    if (isCustomTemplate(state.transform)) {\n        transformString = state.transform(transform, transformString);\n    } else if (transformIsDefault) {\n        transformString = 'none';\n    }\n    return transformString;\n}\nfunction buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase) {\n    if (enableHardwareAcceleration === void 0) {\n        enableHardwareAcceleration = true;\n    }\n    if (styles === void 0) {\n        styles = {};\n    }\n    if (transform === void 0) {\n        transform = {};\n    }\n    if (transformOrigin === void 0) {\n        transformOrigin = {};\n    }\n    if (transformKeys === void 0) {\n        transformKeys = [];\n    }\n    if (isDashCase === void 0) {\n        isDashCase = false;\n    }\n    var transformIsDefault = true;\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    for (var key in state) {\n        var value = state[key];\n        var valueType = getValueType(key);\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            if (transformIsDefault) {\n                if (valueType.default && value !== valueType.default || !valueType.default && value !== 0) {\n                    transformIsDefault = false;\n                }\n            }\n        } else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            hasTransformOrigin = true;\n        } else if (!blacklist.has(key) || !isCustomTemplate(valueAsType)) {\n            styles[prefixer(key, isDashCase)] = valueAsType;\n        }\n    }\n    if (hasTransform || typeof state.transform === 'function') {\n        styles.transform = buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration);\n    }\n    if (hasTransformOrigin) {\n        styles.transformOrigin = (transformOrigin.originX || '50%') + \" \" + (transformOrigin.originY || '50%') + \" \" + (transformOrigin.originZ || 0);\n    }\n    return styles;\n}\nfunction createStyleBuilder(enableHardwareAcceleration, isDashCase) {\n    if (enableHardwareAcceleration === void 0) {\n        enableHardwareAcceleration = true;\n    }\n    if (isDashCase === void 0) {\n        isDashCase = true;\n    }\n    var styles = {};\n    var transform = {};\n    var transformOrigin = {};\n    var transformKeys = [];\n    return function (state) {\n        transformKeys.length = 0;\n        buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase);\n        return styles;\n    };\n}\n\nfunction onRead(key, options) {\n    var element = options.element,\n        preparseOutput = options.preparseOutput;\n    var defaultValueType = getValueType(key);\n    if (isTransformProp(key)) {\n        return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else if (scrollKeys.has(key)) {\n        return element[key];\n    } else {\n        var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;\n        return preparseOutput && defaultValueType && defaultValueType.test(domValue) && defaultValueType.parse ? defaultValueType.parse(domValue) : domValue;\n    }\n}\nfunction onRender(state, _a, changedValues) {\n    var element = _a.element,\n        buildStyles = _a.buildStyles,\n        hasCSSVariable = _a.hasCSSVariable;\n    Object.assign(element.style, buildStyles(state));\n    if (hasCSSVariable) {\n        var numChangedValues = changedValues.length;\n        for (var i = 0; i < numChangedValues; i++) {\n            var key = changedValues[i];\n            if (key.startsWith('--')) {\n                element.style.setProperty(key, state[key]);\n            }\n        }\n    }\n    if (changedValues.indexOf(SCROLL_LEFT) !== -1) {\n        element[SCROLL_LEFT] = state[SCROLL_LEFT];\n    }\n    if (changedValues.indexOf(SCROLL_TOP) !== -1) {\n        element[SCROLL_TOP] = state[SCROLL_TOP];\n    }\n}\nvar cssStyler = /*#__PURE__*/createStyler({\n    onRead: onRead,\n    onRender: onRender,\n    uncachedValues: scrollKeys\n});\nfunction createCssStyler(element, _a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n        props = __rest(_a, [\"enableHardwareAcceleration\"]);\n    return cssStyler(__assign({ element: element, buildStyles: createStyleBuilder(enableHardwareAcceleration), preparseOutput: true }, props));\n}\n\nvar camelCaseAttributes = /*#__PURE__*/new Set(['baseFrequency', 'diffuseConstant', 'kernelMatrix', 'kernelUnitLength', 'keySplines', 'keyTimes', 'limitingConeAngle', 'markerHeight', 'markerWidth', 'numOctaves', 'targetX', 'targetY', 'surfaceScale', 'specularConstant', 'specularExponent', 'stdDeviation', 'tableValues']);\n\nvar svgAttrsTemplate = function () {\n    return {\n        style: {}\n    };\n};\nvar progressToPixels = function (progress, length) {\n    return px.transform(progress * length);\n};\nvar unmeasured = { x: 0, y: 0, width: 0, height: 0 };\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === 'string' ? origin : px.transform(offset + size * origin);\n}\nfunction calculateSVGTransformOrigin(dimensions, originX, originY) {\n    return calcOrigin(originX, dimensions.x, dimensions.width) + \" \" + calcOrigin(originY, dimensions.y, dimensions.height);\n}\nfunction buildSVGAttrs(_a, dimensions, totalPathLength, cssBuilder, attrs, isDashCase) {\n    if (dimensions === void 0) {\n        dimensions = unmeasured;\n    }\n    if (cssBuilder === void 0) {\n        cssBuilder = createStyleBuilder(false, false);\n    }\n    if (attrs === void 0) {\n        attrs = svgAttrsTemplate();\n    }\n    if (isDashCase === void 0) {\n        isDashCase = true;\n    }\n    var x = _a.x,\n        y = _a.y,\n        z = _a.z,\n        _b = _a.originX,\n        originX = _b === void 0 ? 0.5 : _b,\n        _c = _a.originY,\n        originY = _c === void 0 ? 0.5 : _c,\n        pathLength = _a.pathLength,\n        _d = _a.pathSpacing,\n        pathSpacing = _d === void 0 ? 1 : _d,\n        _e = _a.pathOffset,\n        pathOffset = _e === void 0 ? 0 : _e,\n        state = __rest(_a, [\"x\", \"y\", \"z\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    var style = cssBuilder(state);\n    for (var key in style) {\n        if (key === 'transform') {\n            attrs.style.transform = style[key];\n        } else {\n            var attrKey = isDashCase && !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n            attrs[attrKey] = style[key];\n        }\n    }\n    if (originX !== undefined || originY !== undefined) {\n        attrs.style.transformOrigin = calculateSVGTransformOrigin(dimensions, originX, originY);\n    }\n    if (x !== undefined) attrs.x = x;\n    if (y !== undefined) attrs.y = y;\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        attrs[isDashCase ? 'stroke-dashoffset' : 'strokeDashoffset'] = progressToPixels(-pathOffset, totalPathLength);\n        attrs[isDashCase ? 'stroke-dasharray' : 'strokeDasharray'] = progressToPixels(pathLength, totalPathLength) + \" \" + progressToPixels(pathSpacing, totalPathLength);\n    }\n    return attrs;\n}\nfunction createAttrBuilder(dimensions, totalPathLength, isDashCase) {\n    if (isDashCase === void 0) {\n        isDashCase = true;\n    }\n    var attrs = svgAttrsTemplate();\n    var cssBuilder = createStyleBuilder(false, false);\n    return function (state) {\n        return buildSVGAttrs(state, dimensions, totalPathLength, cssBuilder, attrs, isDashCase);\n    };\n}\n\nvar getDimensions = function (element) {\n    return typeof element.getBBox === 'function' ? element.getBBox() : element.getBoundingClientRect();\n};\nvar getSVGElementDimensions = function (element) {\n    try {\n        return getDimensions(element);\n    } catch (e) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n};\n\nvar isPath = function (element) {\n    return element.tagName === 'path';\n};\nvar svgStyler = /*#__PURE__*/createStyler({\n    onRead: function (key, _a) {\n        var element = _a.element;\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        if (!isTransformProp(key)) {\n            return element.getAttribute(key);\n        } else {\n            var valueType = getValueType(key);\n            return valueType ? valueType.default || 0 : 0;\n        }\n    },\n    onRender: function (state, _a) {\n        var element = _a.element,\n            buildAttrs = _a.buildAttrs;\n        var attrs = buildAttrs(state);\n        for (var key in attrs) {\n            if (key === 'style') {\n                Object.assign(element.style, attrs.style);\n            } else {\n                element.setAttribute(key, attrs[key]);\n            }\n        }\n    }\n});\nvar svg = function (element) {\n    var dimensions = getSVGElementDimensions(element);\n    var pathLength = isPath(element) && element.getTotalLength ? element.getTotalLength() : undefined;\n    return svgStyler({\n        element: element,\n        buildAttrs: createAttrBuilder(dimensions, pathLength)\n    });\n};\n\nvar viewport = /*#__PURE__*/createStyler({\n    useCache: false,\n    onRead: function (key) {\n        return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;\n    },\n    onRender: function (_a) {\n        var _b = _a.scrollTop,\n            scrollTop = _b === void 0 ? 0 : _b,\n            _c = _a.scrollLeft,\n            scrollLeft = _c === void 0 ? 0 : _c;\n        return window.scrollTo(scrollLeft, scrollTop);\n    }\n});\n\nvar cache = /*#__PURE__*/new WeakMap();\nvar createDOMStyler = function (node, props) {\n    var styler;\n    if (node instanceof HTMLElement) {\n        styler = createCssStyler(node, props);\n    } else if (node instanceof SVGElement) {\n        styler = svg(node);\n    } else if (node === window) {\n        styler = viewport(node);\n    }\n    invariant(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');\n    cache.set(node, styler);\n    return styler;\n};\nvar getStyler = function (node, props) {\n    return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);\n};\nfunction index(nodeOrSelector, props) {\n    var node = typeof nodeOrSelector === 'string' ? document.querySelector(nodeOrSelector) : nodeOrSelector;\n    return getStyler(node, props);\n}\n\nexport default index;\nexport { createStyler as createStylerFactory, buildStyleProperty, buildSVGAttrs, transformProps, isTransformProp };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { __rest, __assign, __extends } from 'tslib';\nimport { pipe, velocityPerSecond, mixComplex, mixColor, mix, clamp, progress, velocityPerFrame, distance, angle, applyOffset } from '@popmotion/popcorn';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { color, complex, px, percent, degrees, vh, vw, number } from 'style-value-types';\nimport { createReversedEasing, linear, easeOut, easeInOut } from '@popmotion/easing';\nimport { invariant } from 'hey-listen';\n\nvar Observer = /*#__PURE__*/function () {\n    function Observer(_a, observer) {\n        var _this = this;\n        var middleware = _a.middleware,\n            onComplete = _a.onComplete;\n        this.isActive = true;\n        this.update = function (v) {\n            if (_this.observer.update) _this.updateObserver(v);\n        };\n        this.complete = function () {\n            if (_this.observer.complete && _this.isActive) _this.observer.complete();\n            if (_this.onComplete) _this.onComplete();\n            _this.isActive = false;\n        };\n        this.error = function (err) {\n            if (_this.observer.error && _this.isActive) _this.observer.error(err);\n            _this.isActive = false;\n        };\n        this.observer = observer;\n        this.updateObserver = function (v) {\n            return observer.update(v);\n        };\n        this.onComplete = onComplete;\n        if (observer.update && middleware && middleware.length) {\n            middleware.forEach(function (m) {\n                return _this.updateObserver = m(_this.updateObserver, _this.complete);\n            });\n        }\n    }\n    return Observer;\n}();\nvar createObserver = function (observerCandidate, _a, onComplete) {\n    var middleware = _a.middleware;\n    if (typeof observerCandidate === 'function') {\n        return new Observer({ middleware: middleware, onComplete: onComplete }, { update: observerCandidate });\n    } else {\n        return new Observer({ middleware: middleware, onComplete: onComplete }, observerCandidate);\n    }\n};\n\nvar Action = /*#__PURE__*/function () {\n    function Action(props) {\n        if (props === void 0) {\n            props = {};\n        }\n        this.props = props;\n    }\n    Action.prototype.create = function (props) {\n        return new Action(props);\n    };\n    Action.prototype.start = function (observerCandidate) {\n        if (observerCandidate === void 0) {\n            observerCandidate = {};\n        }\n        var isComplete = false;\n        var subscription = {\n            stop: function () {\n                return undefined;\n            }\n        };\n        var _a = this.props,\n            init = _a.init,\n            observerProps = __rest(_a, [\"init\"]);\n        var observer = createObserver(observerCandidate, observerProps, function () {\n            isComplete = true;\n            subscription.stop();\n        });\n        var api = init(observer);\n        subscription = api ? __assign({}, subscription, api) : subscription;\n        if (isComplete) subscription.stop();\n        return subscription;\n    };\n    Action.prototype.applyMiddleware = function (middleware) {\n        return this.create(__assign({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));\n    };\n    Action.prototype.pipe = function () {\n        var funcs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            funcs[_i] = arguments[_i];\n        }\n        var pipedUpdate = funcs.length === 1 ? funcs[0] : pipe.apply(void 0, funcs);\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return update(pipedUpdate(v));\n            };\n        });\n    };\n    return Action;\n}();\nvar action = function (init) {\n    return new Action({ init: init });\n};\n\nvar Chainable = /*#__PURE__*/function () {\n    function Chainable(props) {\n        if (props === void 0) {\n            props = {};\n        }\n        this.props = props;\n    }\n    Chainable.prototype.applyMiddleware = function (middleware) {\n        return this.create(__assign({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));\n    };\n    Chainable.prototype.pipe = function () {\n        var funcs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            funcs[_i] = arguments[_i];\n        }\n        var pipedUpdate = funcs.length === 1 ? funcs[0] : pipe.apply(void 0, funcs);\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return update(pipedUpdate(v));\n            };\n        });\n    };\n    Chainable.prototype.while = function (predicate) {\n        return this.applyMiddleware(function (update, complete) {\n            return function (v) {\n                return predicate(v) ? update(v) : complete();\n            };\n        });\n    };\n    Chainable.prototype.filter = function (predicate) {\n        return this.applyMiddleware(function (update) {\n            return function (v) {\n                return predicate(v) && update(v);\n            };\n        });\n    };\n    return Chainable;\n}();\n\nvar BaseMulticast = /*#__PURE__*/function (_super) {\n    __extends(BaseMulticast, _super);\n    function BaseMulticast() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.subscribers = [];\n        return _this;\n    }\n    BaseMulticast.prototype.complete = function () {\n        this.subscribers.forEach(function (subscriber) {\n            return subscriber.complete();\n        });\n    };\n    BaseMulticast.prototype.error = function (err) {\n        this.subscribers.forEach(function (subscriber) {\n            return subscriber.error(err);\n        });\n    };\n    BaseMulticast.prototype.update = function (v) {\n        for (var i = 0; i < this.subscribers.length; i++) {\n            this.subscribers[i].update(v);\n        }\n    };\n    BaseMulticast.prototype.subscribe = function (observerCandidate) {\n        var _this = this;\n        var observer = createObserver(observerCandidate, this.props);\n        this.subscribers.push(observer);\n        var subscription = {\n            unsubscribe: function () {\n                var index = _this.subscribers.indexOf(observer);\n                if (index !== -1) _this.subscribers.splice(index, 1);\n            }\n        };\n        return subscription;\n    };\n    BaseMulticast.prototype.stop = function () {\n        if (this.parent) this.parent.stop();\n    };\n    return BaseMulticast;\n}(Chainable);\n\nvar Multicast = /*#__PURE__*/function (_super) {\n    __extends(Multicast, _super);\n    function Multicast() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Multicast.prototype.create = function (props) {\n        return new Multicast(props);\n    };\n    return Multicast;\n}(BaseMulticast);\nvar multicast = function () {\n    return new Multicast();\n};\n\nvar ValueReaction = /*#__PURE__*/function (_super) {\n    __extends(ValueReaction, _super);\n    function ValueReaction(props) {\n        var _this = _super.call(this, props) || this;\n        _this.scheduleVelocityCheck = function () {\n            return sync.postRender(_this.velocityCheck);\n        };\n        _this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n            }\n        };\n        _this.prev = _this.current = props.value || 0;\n        _this.updateCurrent = function (v) {\n            return _this.current = v;\n        };\n        _this.getVelocityOfCurrent = function () {\n            return _this.getSingleVelocity(_this.current, _this.prev);\n        };\n        if (props.initialSubscription) _this.subscribe(props.initialSubscription);\n        return _this;\n    }\n    ValueReaction.prototype.create = function (props) {\n        return new ValueReaction(props);\n    };\n    ValueReaction.prototype.get = function () {\n        return this.current;\n    };\n    ValueReaction.prototype.getVelocity = function () {\n        return this.getVelocityOfCurrent();\n    };\n    ValueReaction.prototype.update = function (v) {\n        _super.prototype.update.call(this, v);\n        this.prev = this.current;\n        this.updateCurrent(v);\n        var _a = getFrameData(),\n            delta = _a.delta,\n            timestamp = _a.timestamp;\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        sync.postRender(this.scheduleVelocityCheck);\n    };\n    ValueReaction.prototype.subscribe = function (observerCandidate) {\n        var sub = _super.prototype.subscribe.call(this, observerCandidate);\n        this.subscribers[this.subscribers.length - 1].update(this.current);\n        return sub;\n    };\n    ValueReaction.prototype.getSingleVelocity = function (current, prev) {\n        return typeof current === 'number' && typeof prev === 'number' ? velocityPerSecond(current - prev, this.timeDelta) : velocityPerSecond(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;\n    };\n    return ValueReaction;\n}(BaseMulticast);\nvar value = function (value, initialSubscription) {\n    return new ValueReaction({ value: value, initialSubscription: initialSubscription });\n};\n\nvar createVectorTests = function (typeTests) {\n    var testNames = Object.keys(typeTests);\n    var isVectorProp = function (prop, key) {\n        return prop !== undefined && !typeTests[key](prop);\n    };\n    var getVectorKeys = function (props) {\n        return testNames.reduce(function (vectorKeys, key) {\n            if (isVectorProp(props[key], key)) vectorKeys.push(key);\n            return vectorKeys;\n        }, []);\n    };\n    var testVectorProps = function (props) {\n        return props && testNames.some(function (key) {\n            return isVectorProp(props[key], key);\n        });\n    };\n    return { getVectorKeys: getVectorKeys, testVectorProps: testVectorProps };\n};\nvar unitTypes = [px, percent, degrees, vh, vw];\nvar findUnitType = function (prop) {\n    return unitTypes.find(function (type) {\n        return type.test(prop);\n    });\n};\nvar isUnitProp = function (prop) {\n    return Boolean(findUnitType(prop));\n};\nvar createAction = function (action, props) {\n    return action(props);\n};\nvar createUnitAction = function (action, _a) {\n    var from = _a.from,\n        to = _a.to,\n        props = __rest(_a, [\"from\", \"to\"]);\n    var unitType = findUnitType(from) || findUnitType(to);\n    var transform = unitType.transform,\n        parse = unitType.parse;\n    return action(__assign({}, props, { from: typeof from === 'string' ? parse(from) : from, to: typeof to === 'string' ? parse(to) : to })).pipe(transform);\n};\nvar createMixerAction = function (mixer) {\n    return function (action, _a) {\n        var from = _a.from,\n            to = _a.to,\n            props = __rest(_a, [\"from\", \"to\"]);\n        return action(__assign({}, props, { from: 0, to: 1 })).pipe(mixer(from, to));\n    };\n};\nvar createColorAction = /*#__PURE__*/createMixerAction(mixColor);\nvar createComplexAction = /*#__PURE__*/createMixerAction(mixComplex);\nvar createVectorAction = function (action, typeTests) {\n    var _a = createVectorTests(typeTests),\n        testVectorProps = _a.testVectorProps,\n        getVectorKeys = _a.getVectorKeys;\n    var vectorAction = function (props) {\n        var isVector = testVectorProps(props);\n        if (!isVector) return action(props);\n        var vectorKeys = getVectorKeys(props);\n        var testKey = vectorKeys[0];\n        var testProp = props[testKey];\n        return getActionCreator(testProp)(action, props, vectorKeys);\n    };\n    return vectorAction;\n};\nvar getActionCreator = function (prop) {\n    if (typeof prop === 'number') {\n        return createAction;\n    } else if (isUnitProp(prop)) {\n        return createUnitAction;\n    } else if (color.test(prop)) {\n        return createColorAction;\n    } else if (complex.test(prop)) {\n        return createComplexAction;\n    } else {\n        return createAction;\n    }\n};\n\nvar decay = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var complete = _a.complete,\n            update = _a.update;\n        var _b = props.velocity,\n            velocity = _b === void 0 ? 0 : _b,\n            _c = props.from,\n            from = _c === void 0 ? 0 : _c,\n            _d = props.power,\n            power = _d === void 0 ? 0.8 : _d,\n            _e = props.timeConstant,\n            timeConstant = _e === void 0 ? 350 : _e,\n            _f = props.restDelta,\n            restDelta = _f === void 0 ? 0.5 : _f,\n            modifyTarget = props.modifyTarget;\n        var elapsed = 0;\n        var amplitude = power * velocity;\n        var idealTarget = Math.round(from + amplitude);\n        var target = typeof modifyTarget === 'undefined' ? idealTarget : modifyTarget(idealTarget);\n        var process = sync.update(function (_a) {\n            var frameDelta = _a.delta;\n            elapsed += frameDelta;\n            var delta = -amplitude * Math.exp(-elapsed / timeConstant);\n            var isMoving = delta > restDelta || delta < -restDelta;\n            var current = isMoving ? target + delta : target;\n            update(current);\n            if (!isMoving) {\n                cancelSync.update(process);\n                complete();\n            }\n        }, true);\n        return {\n            stop: function () {\n                return cancelSync.update(process);\n            }\n        };\n    });\n};\nvar vectorDecay = /*#__PURE__*/createVectorAction(decay, {\n    from: number.test,\n    modifyTarget: function (func) {\n        return typeof func === 'function';\n    },\n    velocity: number.test\n});\n\nvar spring = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var _b = props.velocity,\n            velocity = _b === void 0 ? 0.0 : _b;\n        var _c = props.from,\n            from = _c === void 0 ? 0.0 : _c,\n            _d = props.to,\n            to = _d === void 0 ? 0.0 : _d,\n            _e = props.stiffness,\n            stiffness = _e === void 0 ? 100 : _e,\n            _f = props.damping,\n            damping = _f === void 0 ? 10 : _f,\n            _g = props.mass,\n            mass = _g === void 0 ? 1.0 : _g,\n            _h = props.restSpeed,\n            restSpeed = _h === void 0 ? 0.01 : _h,\n            _j = props.restDelta,\n            restDelta = _j === void 0 ? 0.01 : _j;\n        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        var t = 0;\n        var delta = to - from;\n        var position = from;\n        var prevPosition = position;\n        var process = sync.update(function (_a) {\n            var timeDelta = _a.delta;\n            t += timeDelta;\n            var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n            var angularFreq = Math.sqrt(stiffness / mass) / 1000;\n            prevPosition = position;\n            if (dampingRatio < 1) {\n                var envelope = Math.exp(-dampingRatio * angularFreq * t);\n                var expoDecay = angularFreq * Math.sqrt(1.0 - dampingRatio * dampingRatio);\n                position = to - envelope * ((initialVelocity + dampingRatio * angularFreq * delta) / expoDecay * Math.sin(expoDecay * t) + delta * Math.cos(expoDecay * t));\n            } else {\n                var envelope = Math.exp(-angularFreq * t);\n                position = to - envelope * (delta + (initialVelocity + angularFreq * delta) * t);\n            }\n            velocity = velocityPerSecond(position - prevPosition, timeDelta);\n            var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;\n            var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;\n            if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {\n                position = to;\n                update(position);\n                cancelSync.update(process);\n                complete();\n            } else {\n                update(position);\n            }\n        }, true);\n        return {\n            stop: function () {\n                return cancelSync.update(process);\n            }\n        };\n    });\n};\nvar vectorSpring = /*#__PURE__*/createVectorAction(spring, {\n    from: number.test,\n    to: number.test,\n    stiffness: number.test,\n    damping: number.test,\n    mass: number.test,\n    velocity: number.test\n});\n\nvar inertia = function (_a) {\n    var _b = _a.from,\n        from = _b === void 0 ? 0 : _b,\n        _c = _a.velocity,\n        velocity = _c === void 0 ? 0 : _c,\n        min = _a.min,\n        max = _a.max,\n        _d = _a.power,\n        power = _d === void 0 ? 0.8 : _d,\n        _e = _a.timeConstant,\n        timeConstant = _e === void 0 ? 700 : _e,\n        _f = _a.bounceStiffness,\n        bounceStiffness = _f === void 0 ? 500 : _f,\n        _g = _a.bounceDamping,\n        bounceDamping = _g === void 0 ? 10 : _g,\n        _h = _a.restDelta,\n        restDelta = _h === void 0 ? 1 : _h,\n        modifyTarget = _a.modifyTarget;\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var prev = from;\n        var current = from;\n        var activeAnimation;\n        var isSpring = false;\n        var isLessThanMin = function (v) {\n            return min !== undefined && v <= min;\n        };\n        var isMoreThanMax = function (v) {\n            return max !== undefined && v >= max;\n        };\n        var isOutOfBounds = function (v) {\n            return isLessThanMin(v) || isMoreThanMax(v);\n        };\n        var isTravellingAwayFromBounds = function (v, currentVelocity) {\n            return isLessThanMin(v) && currentVelocity < 0 || isMoreThanMax(v) && currentVelocity > 0;\n        };\n        var onUpdate = function (v) {\n            update(v);\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(current - prev, getFrameData().delta);\n            if (activeAnimation && !isSpring && isTravellingAwayFromBounds(v, velocity)) {\n                startSpring({ from: v, velocity: velocity });\n            }\n        };\n        var startAnimation = function (animation, next) {\n            activeAnimation && activeAnimation.stop();\n            activeAnimation = animation.start({\n                update: onUpdate,\n                complete: function () {\n                    if (next) {\n                        next();\n                        return;\n                    }\n                    complete();\n                }\n            });\n        };\n        var startSpring = function (props) {\n            isSpring = true;\n            startAnimation(vectorSpring(__assign({}, props, { to: isLessThanMin(props.from) ? min : max, stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta })));\n        };\n        if (isOutOfBounds(from)) {\n            startSpring({ from: from, velocity: velocity });\n        } else if (velocity !== 0) {\n            var animation = vectorDecay({\n                from: from,\n                velocity: velocity,\n                timeConstant: timeConstant,\n                power: power,\n                restDelta: isOutOfBounds(from) ? 20 : restDelta,\n                modifyTarget: modifyTarget\n            });\n            startAnimation(animation, function () {\n                if (isOutOfBounds(current)) {\n                    startSpring({ from: current, velocity: velocity });\n                } else {\n                    complete();\n                }\n            });\n        } else {\n            complete();\n        }\n        return {\n            stop: function () {\n                return activeAnimation && activeAnimation.stop();\n            }\n        };\n    });\n};\nvar index = /*#__PURE__*/createVectorAction(inertia, {\n    from: number.test,\n    velocity: number.test,\n    min: number.test,\n    max: number.test,\n    damping: number.test,\n    stiffness: number.test,\n    modifyTarget: function (func) {\n        return typeof func === 'function';\n    }\n});\n\nvar frame = function () {\n    return action(function (_a) {\n        var update = _a.update;\n        var initialTime = 0;\n        var process = sync.update(function (_a) {\n            var timestamp = _a.timestamp;\n            if (!initialTime) initialTime = timestamp;\n            update(timestamp - initialTime);\n        }, true, true);\n        return {\n            stop: function () {\n                return cancelSync.update(process);\n            }\n        };\n    });\n};\n\nvar scrubber = function (_a) {\n    var _b = _a.from,\n        from = _b === void 0 ? 0 : _b,\n        _c = _a.to,\n        to = _c === void 0 ? 1 : _c,\n        _d = _a.ease,\n        ease = _d === void 0 ? linear : _d,\n        _e = _a.reverseEase,\n        reverseEase = _e === void 0 ? false : _e;\n    if (reverseEase) {\n        ease = createReversedEasing(ease);\n    }\n    return action(function (_a) {\n        var update = _a.update;\n        return {\n            seek: function (progress) {\n                return update(progress);\n            }\n        };\n    }).pipe(ease, function (v) {\n        return mix(from, to, v);\n    });\n};\nvar vectorScrubber = /*#__PURE__*/createVectorAction(scrubber, {\n    ease: function (func) {\n        return typeof func === 'function';\n    },\n    from: number.test,\n    to: number.test\n});\n\nvar clampProgress = /*#__PURE__*/clamp(0, 1);\nvar tween = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var _b = props.duration,\n            duration = _b === void 0 ? 300 : _b,\n            _c = props.ease,\n            ease = _c === void 0 ? easeOut : _c,\n            _d = props.flip,\n            flip = _d === void 0 ? 0 : _d,\n            _e = props.loop,\n            loop = _e === void 0 ? 0 : _e,\n            _f = props.yoyo,\n            yoyo = _f === void 0 ? 0 : _f,\n            _g = props.repeatDelay,\n            repeatDelay = _g === void 0 ? 0 : _g;\n        var _h = props.from,\n            from = _h === void 0 ? 0 : _h,\n            _j = props.to,\n            to = _j === void 0 ? 1 : _j,\n            _k = props.elapsed,\n            elapsed = _k === void 0 ? 0 : _k,\n            _l = props.flipCount,\n            flipCount = _l === void 0 ? 0 : _l,\n            _m = props.yoyoCount,\n            yoyoCount = _m === void 0 ? 0 : _m,\n            _o = props.loopCount,\n            loopCount = _o === void 0 ? 0 : _o;\n        var playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);\n        var currentProgress = 0;\n        var process;\n        var isActive = false;\n        var reverseAnimation = function (reverseEase) {\n            var _a;\n            if (reverseEase === void 0) {\n                reverseEase = false;\n            }\n            _a = [to, from], from = _a[0], to = _a[1];\n            playhead = vectorScrubber({ from: from, to: to, ease: ease, reverseEase: reverseEase }).start(update);\n        };\n        var isTweenComplete = function () {\n            var isComplete = isActive && elapsed > duration + repeatDelay;\n            if (!isComplete) return false;\n            if (isComplete && !loop && !flip && !yoyo) return true;\n            var overtime = elapsed - duration;\n            elapsed = overtime - repeatDelay;\n            if (loop && loopCount < loop) {\n                loopCount++;\n                return false;\n            } else if (flip && flipCount < flip) {\n                flipCount++;\n                reverseAnimation();\n                return false;\n            } else if (yoyo && yoyoCount < yoyo) {\n                yoyoCount++;\n                reverseAnimation(yoyoCount % 2 !== 0);\n                return false;\n            }\n            return true;\n        };\n        var updateTween = function () {\n            currentProgress = clampProgress(progress(0, duration, elapsed));\n            playhead.seek(currentProgress);\n        };\n        var startTimer = function () {\n            isActive = true;\n            process = sync.update(function (_a) {\n                var delta = _a.delta;\n                elapsed += delta;\n                updateTween();\n                if (isTweenComplete()) {\n                    cancelSync.update(process);\n                    complete && sync.update(complete, false, true);\n                }\n            }, true);\n        };\n        var stopTimer = function () {\n            isActive = false;\n            if (process) cancelSync.update(process);\n        };\n        startTimer();\n        return {\n            isActive: function () {\n                return isActive;\n            },\n            getElapsed: function () {\n                return clamp(0, duration, elapsed);\n            },\n            getProgress: function () {\n                return currentProgress;\n            },\n            stop: function () {\n                stopTimer();\n            },\n            pause: function () {\n                stopTimer();\n                return this;\n            },\n            resume: function () {\n                if (!isActive) startTimer();\n                return this;\n            },\n            seek: function (newProgress) {\n                elapsed = mix(0, duration, newProgress);\n                sync.update(updateTween, false, true);\n                return this;\n            },\n            reverse: function () {\n                reverseAnimation();\n                return this;\n            }\n        };\n    });\n};\n\nvar clampProgress$1 = /*#__PURE__*/clamp(0, 1);\nvar defaultEasings = function (values, easing) {\n    return values.map(function () {\n        return easing || easeOut;\n    }).splice(0, values.length - 1);\n};\nvar defaultTimings = function (values) {\n    var numValues = values.length;\n    return values.map(function (value, i) {\n        return i !== 0 ? i / (numValues - 1) : 0;\n    });\n};\nvar interpolateScrubbers = function (input, scrubbers, update) {\n    var rangeLength = input.length;\n    var finalInputIndex = rangeLength - 1;\n    var finalScrubberIndex = finalInputIndex - 1;\n    var subs = scrubbers.map(function (scrub) {\n        return scrub.start(update);\n    });\n    return function (v) {\n        if (v <= input[0]) {\n            subs[0].seek(0);\n        }\n        if (v >= input[finalInputIndex]) {\n            subs[finalScrubberIndex].seek(1);\n        }\n        var i = 1;\n        for (; i < rangeLength; i++) {\n            if (input[i] > v || i === finalInputIndex) break;\n        }\n        var progressInRange = progress(input[i - 1], input[i], v);\n        subs[i - 1].seek(clampProgress$1(progressInRange));\n    };\n};\nvar keyframes = function (_a) {\n    var easings = _a.easings,\n        _b = _a.ease,\n        ease = _b === void 0 ? linear : _b,\n        times = _a.times,\n        values = _a.values,\n        tweenProps = __rest(_a, [\"easings\", \"ease\", \"times\", \"values\"]);\n    easings = Array.isArray(easings) ? easings : defaultEasings(values, easings);\n    times = times || defaultTimings(values);\n    var scrubbers = easings.map(function (easing, i) {\n        return vectorScrubber({\n            from: values[i],\n            to: values[i + 1],\n            ease: easing\n        });\n    });\n    return tween(__assign({}, tweenProps, { ease: ease })).applyMiddleware(function (update) {\n        return interpolateScrubbers(times, scrubbers, update);\n    });\n};\n\nvar physics = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return action(function (_a) {\n        var complete = _a.complete,\n            update = _a.update;\n        var _b = props.acceleration,\n            acceleration = _b === void 0 ? 0 : _b,\n            _c = props.friction,\n            friction = _c === void 0 ? 0 : _c,\n            _d = props.velocity,\n            velocity = _d === void 0 ? 0 : _d,\n            springStrength = props.springStrength,\n            to = props.to;\n        var _e = props.restSpeed,\n            restSpeed = _e === void 0 ? 0.001 : _e,\n            _f = props.from,\n            from = _f === void 0 ? 0 : _f;\n        var current = from;\n        var process = sync.update(function (_a) {\n            var delta = _a.delta;\n            var elapsed = Math.max(delta, 16);\n            if (acceleration) velocity += velocityPerFrame(acceleration, elapsed);\n            if (friction) velocity *= Math.pow(1 - friction, elapsed / 100);\n            if (springStrength !== undefined && to !== undefined) {\n                var distanceToTarget = to - current;\n                velocity += distanceToTarget * velocityPerFrame(springStrength, elapsed);\n            }\n            current += velocityPerFrame(velocity, elapsed);\n            update(current);\n            var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);\n            if (isComplete) {\n                cancelSync.update(process);\n                complete();\n            }\n        }, true);\n        return {\n            set: function (v) {\n                current = v;\n                return this;\n            },\n            setAcceleration: function (v) {\n                acceleration = v;\n                return this;\n            },\n            setFriction: function (v) {\n                friction = v;\n                return this;\n            },\n            setSpringStrength: function (v) {\n                springStrength = v;\n                return this;\n            },\n            setSpringTarget: function (v) {\n                to = v;\n                return this;\n            },\n            setVelocity: function (v) {\n                velocity = v;\n                return this;\n            },\n            stop: function () {\n                return cancelSync.update(process);\n            }\n        };\n    });\n};\nvar vectorPhysics = /*#__PURE__*/createVectorAction(physics, {\n    acceleration: number.test,\n    friction: number.test,\n    velocity: number.test,\n    from: number.test,\n    to: number.test,\n    springStrength: number.test\n});\n\nvar multi = function (_a) {\n    var getCount = _a.getCount,\n        getFirst = _a.getFirst,\n        getOutput = _a.getOutput,\n        mapApi = _a.mapApi,\n        setProp = _a.setProp,\n        startActions = _a.startActions;\n    return function (actions) {\n        return action(function (_a) {\n            var update = _a.update,\n                complete = _a.complete,\n                error = _a.error;\n            var numActions = getCount(actions);\n            var output = getOutput();\n            var updateOutput = function () {\n                return update(output);\n            };\n            var numCompletedActions = 0;\n            var subs = startActions(actions, function (a, name) {\n                var hasCompleted = false;\n                return a.start({\n                    complete: function () {\n                        if (!hasCompleted) {\n                            hasCompleted = true;\n                            numCompletedActions++;\n                            if (numCompletedActions === numActions) sync.update(complete);\n                        }\n                    },\n                    error: error,\n                    update: function (v) {\n                        setProp(output, name, v);\n                        sync.update(updateOutput, false, true);\n                    }\n                });\n            });\n            return Object.keys(getFirst(subs)).reduce(function (api, methodName) {\n                api[methodName] = mapApi(subs, methodName);\n                return api;\n            }, {});\n        });\n    };\n};\n\nvar composite = /*#__PURE__*/multi({\n    getOutput: function () {\n        return {};\n    },\n    getCount: function (subs) {\n        return Object.keys(subs).length;\n    },\n    getFirst: function (subs) {\n        return subs[Object.keys(subs)[0]];\n    },\n    mapApi: function (subs, methodName) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return Object.keys(subs).reduce(function (output, propKey) {\n                var _a;\n                if (subs[propKey][methodName]) {\n                    args[0] && args[0][propKey] !== undefined ? output[propKey] = subs[propKey][methodName](args[0][propKey]) : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);\n                }\n                return output;\n            }, {});\n        };\n    },\n    setProp: function (output, name, v) {\n        return output[name] = v;\n    },\n    startActions: function (actions, starter) {\n        return Object.keys(actions).reduce(function (subs, key) {\n            subs[key] = starter(actions[key], key);\n            return subs;\n        }, {});\n    }\n});\n\nvar DEFAULT_DURATION = 300;\nvar flattenTimings = function (instructions) {\n    var flatInstructions = [];\n    var lastArg = instructions[instructions.length - 1];\n    var isStaggered = typeof lastArg === 'number';\n    var staggerDelay = isStaggered ? lastArg : 0;\n    var segments = isStaggered ? instructions.slice(0, -1) : instructions;\n    var numSegments = segments.length;\n    var offset = 0;\n    segments.forEach(function (item, i) {\n        flatInstructions.push(item);\n        if (i !== numSegments - 1) {\n            var duration = item.duration || DEFAULT_DURATION;\n            offset += staggerDelay;\n            flatInstructions.push(\"-\" + (duration - offset));\n        }\n    });\n    return flatInstructions;\n};\nvar flattenArrayInstructions = function (instructions, instruction) {\n    Array.isArray(instruction) ? instructions.push.apply(instructions, flattenTimings(instruction)) : instructions.push(instruction);\n    return instructions;\n};\nvar convertDefToProps = function (props, def, i) {\n    var duration = props.duration,\n        easings = props.easings,\n        times = props.times,\n        values = props.values;\n    var numValues = values.length;\n    var prevTimeTo = times[numValues - 1];\n    var timeFrom = def.at === 0 ? 0 : def.at / duration;\n    var timeTo = (def.at + def.duration) / duration;\n    if (i === 0) {\n        values.push(def.from);\n        times.push(timeFrom);\n    } else {\n        if (prevTimeTo !== timeFrom) {\n            if (def.from !== undefined) {\n                values.push(values[numValues - 1]);\n                times.push(timeFrom);\n                easings.push(linear);\n            }\n            var from = def.from !== undefined ? def.from : values[numValues - 1];\n            values.push(from);\n            times.push(timeFrom);\n            easings.push(linear);\n        } else if (def.from !== undefined) {\n            values.push(def.from);\n            times.push(timeFrom);\n            easings.push(linear);\n        }\n    }\n    values.push(def.to);\n    times.push(timeTo);\n    easings.push(def.ease || easeInOut);\n    return props;\n};\nvar timeline = function (instructions, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        duration = _b.duration,\n        elapsed = _b.elapsed,\n        ease = _b.ease,\n        loop = _b.loop,\n        flip = _b.flip,\n        yoyo = _b.yoyo;\n    var playhead = 0;\n    var calculatedDuration = 0;\n    var flatInstructions = instructions.reduce(flattenArrayInstructions, []);\n    var animationDefs = [];\n    flatInstructions.forEach(function (instruction) {\n        if (typeof instruction === 'string') {\n            playhead += parseFloat(instruction);\n        } else if (typeof instruction === 'number') {\n            playhead = instruction;\n        } else {\n            var def = __assign({}, instruction, { at: playhead });\n            def.duration = def.duration === undefined ? DEFAULT_DURATION : def.duration;\n            animationDefs.push(def);\n            playhead += def.duration;\n            calculatedDuration = Math.max(calculatedDuration, def.at + def.duration);\n        }\n    });\n    var tracks = {};\n    var numDefs = animationDefs.length;\n    for (var i = 0; i < numDefs; i++) {\n        var def = animationDefs[i];\n        var track = def.track;\n        if (track === undefined) {\n            throw new Error('No track defined');\n        }\n        if (!tracks.hasOwnProperty(track)) tracks[track] = [];\n        tracks[track].push(def);\n    }\n    var trackKeyframes = {};\n    for (var key in tracks) {\n        if (tracks.hasOwnProperty(key)) {\n            var keyframeProps = tracks[key].reduce(convertDefToProps, {\n                duration: calculatedDuration,\n                easings: [],\n                times: [],\n                values: []\n            });\n            trackKeyframes[key] = keyframes(__assign({}, keyframeProps, { duration: duration || calculatedDuration, ease: ease,\n                elapsed: elapsed,\n                loop: loop,\n                yoyo: yoyo,\n                flip: flip }));\n        }\n    }\n    return composite(trackKeyframes);\n};\n\nvar listen = function (element, events, options) {\n    return action(function (_a) {\n        var update = _a.update;\n        var eventNames = events.split(' ').map(function (eventName) {\n            element.addEventListener(eventName, update, options);\n            return eventName;\n        });\n        return {\n            stop: function () {\n                return eventNames.forEach(function (eventName) {\n                    return element.removeEventListener(eventName, update, options);\n                });\n            }\n        };\n    });\n};\n\nvar defaultPointerPos = function () {\n    return {\n        clientX: 0,\n        clientY: 0,\n        pageX: 0,\n        pageY: 0,\n        x: 0,\n        y: 0\n    };\n};\nvar eventToPoint = function (e, point) {\n    if (point === void 0) {\n        point = defaultPointerPos();\n    }\n    point.clientX = point.x = e.clientX;\n    point.clientY = point.y = e.clientY;\n    point.pageX = e.pageX;\n    point.pageY = e.pageY;\n    return point;\n};\n\nvar points = [/*#__PURE__*/defaultPointerPos()];\nvar isTouchDevice = false;\nif (typeof document !== 'undefined') {\n    var updatePointsLocation = function (_a) {\n        var touches = _a.touches;\n        isTouchDevice = true;\n        var numTouches = touches.length;\n        points.length = 0;\n        for (var i = 0; i < numTouches; i++) {\n            var thisTouch = touches[i];\n            points.push(eventToPoint(thisTouch));\n        }\n    };\n    listen(document, 'touchstart touchmove', {\n        passive: true,\n        capture: true\n    }).start(updatePointsLocation);\n}\nvar multitouch = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.preventDefault,\n        preventDefault = _c === void 0 ? true : _c,\n        _d = _b.scale,\n        scale = _d === void 0 ? 1.0 : _d,\n        _e = _b.rotate,\n        rotate = _e === void 0 ? 0.0 : _e;\n    return action(function (_a) {\n        var update = _a.update;\n        var output = {\n            touches: points,\n            scale: scale,\n            rotate: rotate\n        };\n        var initialDistance = 0.0;\n        var initialRotation = 0.0;\n        var isGesture = points.length > 1;\n        if (isGesture) {\n            var firstTouch = points[0],\n                secondTouch = points[1];\n            initialDistance = distance(firstTouch, secondTouch);\n            initialRotation = angle(firstTouch, secondTouch);\n        }\n        var updatePoint = function () {\n            if (isGesture) {\n                var firstTouch = points[0],\n                    secondTouch = points[1];\n                var newDistance = distance(firstTouch, secondTouch);\n                var newRotation = angle(firstTouch, secondTouch);\n                output.scale = scale * (newDistance / initialDistance);\n                output.rotate = rotate + (newRotation - initialRotation);\n            }\n            update(output);\n        };\n        var onMove = function (e) {\n            if (preventDefault || e.touches.length > 1) e.preventDefault();\n            sync.update(updatePoint);\n        };\n        var updateOnMove = listen(document, 'touchmove', {\n            passive: !preventDefault\n        }).start(onMove);\n        if (isTouchDevice) sync.update(updatePoint);\n        return {\n            stop: function () {\n                cancelSync.update(updatePoint);\n                updateOnMove.stop();\n            }\n        };\n    });\n};\nvar getIsTouchDevice = function () {\n    return isTouchDevice;\n};\n\nvar point = /*#__PURE__*/defaultPointerPos();\nvar isMouseDevice = false;\nif (typeof document !== 'undefined') {\n    var updatePointLocation = function (e) {\n        isMouseDevice = true;\n        eventToPoint(e, point);\n    };\n    listen(document, 'mousedown mousemove', true).start(updatePointLocation);\n}\nvar mouse = function (_a) {\n    var _b = (_a === void 0 ? {} : _a).preventDefault,\n        preventDefault = _b === void 0 ? true : _b;\n    return action(function (_a) {\n        var update = _a.update;\n        var updatePoint = function () {\n            return update(point);\n        };\n        var onMove = function (e) {\n            if (preventDefault) e.preventDefault();\n            sync.update(updatePoint);\n        };\n        var updateOnMove = listen(document, 'mousemove').start(onMove);\n        if (isMouseDevice) sync.update(updatePoint);\n        return {\n            stop: function () {\n                cancelSync.update(updatePoint);\n                updateOnMove.stop();\n            }\n        };\n    });\n};\n\nvar getFirstTouch = function (_a) {\n    var firstTouch = _a[0];\n    return firstTouch;\n};\nvar pointer = function (props) {\n    if (props === void 0) {\n        props = {};\n    }\n    return getIsTouchDevice() ? multitouch(props).pipe(function (_a) {\n        var touches = _a.touches;\n        return touches;\n    }, getFirstTouch) : mouse(props);\n};\nvar index$1 = function (_a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var x = _a.x,\n        y = _a.y,\n        props = __rest(_a, [\"x\", \"y\"]);\n    if (x !== undefined || y !== undefined) {\n        var applyXOffset_1 = applyOffset(x || 0);\n        var applyYOffset_1 = applyOffset(y || 0);\n        var delta_1 = { x: 0, y: 0 };\n        return pointer(props).pipe(function (point) {\n            delta_1.x = applyXOffset_1(point.x);\n            delta_1.y = applyYOffset_1(point.y);\n            return delta_1;\n        });\n    } else {\n        return pointer(props);\n    }\n};\n\nvar chain = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var i = 0;\n        var current;\n        var playCurrent = function () {\n            current = actions[i].start({\n                complete: function () {\n                    i++;\n                    i >= actions.length ? complete() : playCurrent();\n                },\n                update: update\n            });\n        };\n        playCurrent();\n        return {\n            stop: function () {\n                return current && current.stop();\n            }\n        };\n    });\n};\n\nvar parallel = /*#__PURE__*/multi({\n    getOutput: function () {\n        return [];\n    },\n    getCount: function (subs) {\n        return subs.length;\n    },\n    getFirst: function (subs) {\n        return subs[0];\n    },\n    mapApi: function (subs, methodName) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return subs.map(function (sub, i) {\n                if (sub[methodName]) {\n                    return Array.isArray(args[0]) ? sub[methodName](args[0][i]) : sub[methodName].apply(sub, args);\n                }\n            });\n        };\n    },\n    setProp: function (output, name, v) {\n        return output[name] = v;\n    },\n    startActions: function (actions, starter) {\n        return actions.map(function (action, i) {\n            return starter(action, i);\n        });\n    }\n});\nvar parallel$1 = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return parallel(actions);\n};\n\nvar crossfade = function (a, b) {\n    return action(function (observer) {\n        var balance = 0;\n        var fadable = parallel$1(a, b).start(__assign({}, observer, { update: function (_a) {\n                var va = _a[0],\n                    vb = _a[1];\n                observer.update(mix(va, vb, balance));\n            } }));\n        return {\n            setBalance: function (v) {\n                return balance = v;\n            },\n            stop: function () {\n                return fadable.stop();\n            }\n        };\n    });\n};\n\nvar delay = function (timeToDelay) {\n    return action(function (_a) {\n        var complete = _a.complete;\n        var timeout = setTimeout(complete, timeToDelay);\n        return {\n            stop: function () {\n                return clearTimeout(timeout);\n            }\n        };\n    });\n};\n\nvar merge = function () {\n    var actions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        actions[_i] = arguments[_i];\n    }\n    return action(function (observer) {\n        var subs = actions.map(function (thisAction) {\n            return thisAction.start(observer);\n        });\n        return {\n            stop: function () {\n                return subs.forEach(function (sub) {\n                    return sub.stop();\n                });\n            }\n        };\n    });\n};\n\nvar schedule = function (scheduler, schedulee) {\n    return action(function (_a) {\n        var update = _a.update,\n            complete = _a.complete;\n        var latest;\n        var schedulerSub = scheduler.start({\n            update: function () {\n                return latest !== undefined && update(latest);\n            },\n            complete: complete\n        });\n        var scheduleeSub = schedulee.start({\n            update: function (v) {\n                return latest = v;\n            },\n            complete: complete\n        });\n        return {\n            stop: function () {\n                schedulerSub.stop();\n                scheduleeSub.stop();\n            }\n        };\n    });\n};\n\nvar stagger = function (actions, interval) {\n    var intervalIsNumber = typeof interval === 'number';\n    var actionsWithDelay = actions.map(function (a, i) {\n        var timeToDelay = intervalIsNumber ? interval * i : interval(i);\n        return chain(delay(timeToDelay), a);\n    });\n    return parallel$1.apply(void 0, actionsWithDelay);\n};\n\nvar styler = function () {\n    return invariant(false, 'styler has been removed from Popmotion in 9.0. Downgrade to 8.x or npm install stylefire');\n};\n\nexport { Action, ValueReaction, action, chain, composite, crossfade, vectorDecay as decay, delay, frame as everyFrame, index as inertia, keyframes, listen, merge, mouse, multicast, multitouch, parallel$1 as parallel, vectorPhysics as physics, index$1 as pointer, schedule, vectorSpring as spring, stagger, styler, timeline, tween, value };\n","import { __assign, __rest } from 'tslib';\nimport { useRef, useEffect, memo, forwardRef, createContext, useMemo, useContext, createElement, Fragment, useCallback, useState, useLayoutEffect, cloneElement, Children, isValidElement } from 'react';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, distance, mix, interpolate, wrap } from '@popmotion/popcorn';\nimport styler, { createStylerFactory, buildStyleProperty, isTransformProp, transformProps, buildSVGAttrs } from 'stylefire';\nimport { invariant, warning } from 'hey-listen';\nimport { number, px, percent, degrees, vw, vh, color, complex } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\n\n/**\r\n * Uses the ref that is passed in, or creates a new one\r\n * @param external - External ref\r\n * @internal\r\n */\r\nfunction useExternalRef(external) {\r\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\r\n    // shouldn't be called conditionally. However, Framer Motion will break if this\r\n    // condition changes anyway. It might be possible to use an invariant here to\r\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\r\n    var ref = !external || typeof external === \"function\" ? useRef(null) : external;\r\n    useEffect(function () {\r\n        if (external && typeof external === \"function\") {\r\n            external(ref.current);\r\n            return function () { return external(null); };\r\n        }\r\n    }, []);\r\n    return ref;\r\n}\n\nvar isFloat = function (value) {\r\n    return !isNaN(parseFloat(value));\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nvar MotionValue = /** @class */ (function () {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    function MotionValue(init, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, transformer = _b.transformer, parent = _b.parent;\r\n        /**\r\n         * Duration, in milliseconds, since last updating frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.timeDelta = 0;\r\n        /**\r\n         * Timestamp of the last time this `MotionValue` was updated.\r\n         *\r\n         * @internal\r\n         */\r\n        this.lastUpdated = 0;\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = false;\r\n        this.updateAndNotify = function (v, render) {\r\n            if (render === void 0) { render = true; }\r\n            _this.prev = _this.current;\r\n            _this.current = _this.transformer ? _this.transformer(v) : v;\r\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\r\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            if (_this.children) {\r\n                _this.children.forEach(_this.setChild);\r\n            }\r\n            if (render && _this.renderSubscribers) {\r\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            // Update timestamp\r\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\r\n            if (_this.lastUpdated !== timestamp) {\r\n                _this.timeDelta = delta;\r\n                _this.lastUpdated = timestamp;\r\n                sync.postRender(_this.scheduleVelocityCheck);\r\n            }\r\n        };\r\n        /**\r\n         * Notify a subscriber with the latest value.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @param subscriber - The subscriber to notify.\r\n         *\r\n         * @internal\r\n         */\r\n        this.notifySubscriber = function (subscriber) {\r\n            subscriber(_this.current);\r\n        };\r\n        /**\r\n         * Schedule a velocity check for the next frame.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\r\n        /**\r\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\r\n         * This ensures velocity calculations return `0`.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.velocityCheck = function (_a) {\r\n            var timestamp = _a.timestamp;\r\n            if (timestamp !== _this.lastUpdated) {\r\n                _this.prev = _this.current;\r\n            }\r\n        };\r\n        /**\r\n         * Updates child `MotionValue`.\r\n         *\r\n         * @param child - Child `MotionValue`.\r\n         *\r\n         * @internal\r\n         */\r\n        this.setChild = function (child) { return child.set(_this.current); };\r\n        this.parent = parent;\r\n        this.transformer = transformer;\r\n        this.set(init, false);\r\n        this.canTrackVelocity = isFloat(this.current);\r\n    }\r\n    /**\r\n     * Creates a new `MotionValue` that's subscribed to the output of this one.\r\n     *\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.addChild = function (config) {\r\n        if (config === void 0) { config = {}; }\r\n        var child = new MotionValue(this.current, __assign({ parent: this }, config));\r\n        if (!this.children)\r\n            this.children = new Set();\r\n        this.children.add(child);\r\n        return child;\r\n    };\r\n    /**\r\n     * Stops a `MotionValue` from being subscribed to this one.\r\n     *\r\n     * @param child - The subscribed `MotionValue`\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.removeChild = function (child) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(child);\r\n    };\r\n    /**\r\n     * Subscribes a subscriber function to a subscription list.\r\n     *\r\n     * @param subscriptions - A `Set` of subscribers.\r\n     * @param subscription - A subscriber function.\r\n     */\r\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\r\n        var _this = this;\r\n        var updateSubscriber = function () { return subscription(_this.current); };\r\n        subscriptions.add(updateSubscriber);\r\n        return function () { return subscriptions.delete(updateSubscriber); };\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * @library\r\n     *\r\n     * ```jsx\r\n     * function MyComponent() {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <Frame x={x} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @motion\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     *\r\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\r\n     *\r\n     * ```jsx\r\n     * useOnChange(x, () => {})\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.onChange = function (subscription) {\r\n        if (!this.updateSubscribers)\r\n            this.updateSubscribers = new Set();\r\n        return this.subscribeTo(this.updateSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` requests a render.\r\n     *\r\n     * @param subscriber - A function that's provided the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.onRenderRequest = function (subscription) {\r\n        if (!this.renderSubscribers)\r\n            this.renderSubscribers = new Set();\r\n        // Render immediately\r\n        this.notifySubscriber(subscription);\r\n        return this.subscribeTo(this.renderSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.attach = function (passiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n    };\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.set = function (v, render) {\r\n        if (render === void 0) { render = true; }\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.get = function () {\r\n        return this.current;\r\n    };\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.getVelocity = function () {\r\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\r\n        return this.canTrackVelocity\r\n            ? // These casts could be avoided if parseFloat would be typed better\r\n                velocityPerSecond(parseFloat(this.current) -\r\n                    parseFloat(this.prev), this.timeDelta)\r\n            : 0;\r\n    };\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.start = function (animation) {\r\n        var _this = this;\r\n        this.stop();\r\n        return new Promise(function (resolve) {\r\n            _this.stopAnimation = animation(resolve);\r\n        }).then(function () { return _this.clearAnimation(); });\r\n    };\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.stop = function () {\r\n        if (this.stopAnimation)\r\n            this.stopAnimation();\r\n        this.clearAnimation();\r\n    };\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.isAnimating = function () {\r\n        return !!this.stopAnimation;\r\n    };\r\n    MotionValue.prototype.clearAnimation = function () {\r\n        this.stopAnimation = null;\r\n    };\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.destroy = function () {\r\n        this.updateSubscribers && this.updateSubscribers.clear();\r\n        this.renderSubscribers && this.renderSubscribers.clear();\r\n        this.parent && this.parent.removeChild(this);\r\n        this.stop();\r\n    };\r\n    return MotionValue;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nfunction motionValue(init, opts) {\r\n    return new MotionValue(init, opts);\r\n}\n\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    var ref = useRef(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\n\nvar isMotionValue = function (value) {\r\n    return value instanceof MotionValue;\r\n};\n\nvar session = null;\r\nvar syncRenderSession = {\r\n    isOpen: function () { return session !== null; },\r\n    open: function () {\r\n        invariant(!session, \"Sync render session already open\");\r\n        session = [];\r\n    },\r\n    flush: function () {\r\n        invariant(session !== null, \"No sync render session found\");\r\n        session && session.forEach(function (styler) { return styler.render(); });\r\n        session = null;\r\n    },\r\n    push: function (styler) {\r\n        invariant(session !== null, \"No sync render session found\");\r\n        session && session.push(styler);\r\n    },\r\n};\n\n// Creating a styler factory for the `onUpdate` prop allows all values\r\n// to fire and the `onUpdate` prop will only fire once per frame\r\nvar updateStyler = createStylerFactory({\r\n    onRead: function () { return null; },\r\n    onRender: function (state, _a) {\r\n        var onUpdate = _a.onUpdate;\r\n        return onUpdate(state);\r\n    },\r\n});\r\nvar MotionValuesMap = /** @class */ (function () {\r\n    function MotionValuesMap() {\r\n        this.hasMounted = false;\r\n        this.values = new Map();\r\n        this.unsubscribers = new Map();\r\n    }\r\n    MotionValuesMap.prototype.has = function (key) {\r\n        return this.values.has(key);\r\n    };\r\n    MotionValuesMap.prototype.set = function (key, value) {\r\n        this.values.set(key, value);\r\n        if (this.hasMounted) {\r\n            this.bindValueToOutput(key, value);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.get = function (key, defaultValue) {\r\n        var value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = new MotionValue(defaultValue);\r\n            this.set(key, value);\r\n        }\r\n        return value;\r\n    };\r\n    MotionValuesMap.prototype.forEach = function (callback) {\r\n        return this.values.forEach(callback);\r\n    };\r\n    MotionValuesMap.prototype.bindValueToOutput = function (key, value) {\r\n        var _this = this;\r\n        var onRender = function (v) { return _this.output && _this.output(key, v); };\r\n        var unsubscribeOnRender = value.onRenderRequest(onRender);\r\n        var onChange = function (v) {\r\n            _this.onUpdate && _this.onUpdate.set(key, v);\r\n        };\r\n        var unsubscribeOnChange = value.onChange(onChange);\r\n        if (this.unsubscribers.has(key)) {\r\n            this.unsubscribers.get(key)();\r\n        }\r\n        this.unsubscribers.set(key, function () {\r\n            unsubscribeOnRender();\r\n            unsubscribeOnChange();\r\n        });\r\n    };\r\n    MotionValuesMap.prototype.setOnUpdate = function (onUpdate) {\r\n        this.onUpdate = undefined;\r\n        if (onUpdate) {\r\n            this.onUpdate = updateStyler({ onUpdate: onUpdate });\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.setTransformTemplate = function (transformTemplate) {\r\n        if (this.transformTemplate !== transformTemplate) {\r\n            this.transformTemplate = transformTemplate;\r\n            this.updateTransformTemplate();\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.getTransformTemplate = function () {\r\n        return this.transformTemplate;\r\n    };\r\n    MotionValuesMap.prototype.updateTransformTemplate = function () {\r\n        if (this.output) {\r\n            this.output(\"transform\", this.transformTemplate);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.mount = function (output) {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        if (output)\r\n            this.output = output;\r\n        this.values.forEach(function (value, key) { return _this.bindValueToOutput(key, value); });\r\n        this.updateTransformTemplate();\r\n    };\r\n    MotionValuesMap.prototype.unmount = function () {\r\n        var _this = this;\r\n        this.values.forEach(function (_value, key) {\r\n            var unsubscribe = _this.unsubscribers.get(key);\r\n            unsubscribe && unsubscribe();\r\n        });\r\n    };\r\n    return MotionValuesMap;\r\n}());\r\nvar specialMotionValueProps = new Set([\"dragOriginX\", \"dragOriginY\"]);\r\nvar useMotionValues = function (props) {\r\n    var motionValues = useConstant(function () {\r\n        var map = new MotionValuesMap();\r\n        /**\r\n         * Loop through every prop and add any detected `MotionValue`s. This is SVG-specific\r\n         * code that should be extracted, perhaps considered hollistically with `useMotionStyles`.\r\n         *\r\n         * <motion.circle cx={motionValue(0)} />\r\n         */\r\n        for (var key in props) {\r\n            if (isMotionValue(props[key]) &&\r\n                !specialMotionValueProps.has(key)) {\r\n                map.set(key, props[key]);\r\n            }\r\n        }\r\n        return map;\r\n    });\r\n    motionValues.setOnUpdate(props.onUpdate);\r\n    motionValues.setTransformTemplate(props.transformTemplate);\r\n    return motionValues;\r\n};\r\n/**\r\n * `useEffect` gets resolved bottom-up. We defer some optional functionality to child\r\n * components, so to ensure everything runs correctly we export the ref-binding logic\r\n * to a new component rather than in `useMotionValues`.\r\n */\r\nvar MountMotionValuesComponent = function (_a, ref) {\r\n    var values = _a.values, isStatic = _a.isStatic;\r\n    useEffect(function () {\r\n        invariant(ref.current instanceof Element, \"No `ref` found. Ensure components created with `motion.custom` forward refs using `React.forwardRef`\");\r\n        var domStyler = styler(ref.current, {\r\n            preparseOutput: false,\r\n            enableHardwareAcceleration: !isStatic,\r\n        });\r\n        values.mount(function (key, value) {\r\n            domStyler.set(key, value);\r\n            if (syncRenderSession.isOpen()) {\r\n                syncRenderSession.push(domStyler);\r\n            }\r\n        });\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return null;\r\n};\r\nvar MountMotionValues = memo(forwardRef(MountMotionValuesComponent));\n\nvar createValueResolver = function (resolver) { return function (values) {\r\n    var resolvedValues = {};\r\n    values.forEach(function (value, key) { return (resolvedValues[key] = resolver(value)); });\r\n    return resolvedValues;\r\n}; };\r\nvar resolveCurrent = createValueResolver(function (value) { return value.get(); });\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\r\nvar isTransformOriginProp = function (key) { return transformOriginProps.has(key); };\r\nvar buildStyleAttr = function (values, styleProp, isStatic) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var transformTemplate = values.getTransformTemplate();\r\n    if (transformTemplate) {\r\n        // If `transform` has been manually set as a string, pass that through the template\r\n        // otherwise pass it forward to Stylefire's style property builder\r\n        motionValueStyles.transform = styleProp.transform\r\n            ? transformTemplate({}, styleProp.transform)\r\n            : transformTemplate;\r\n    }\r\n    return __assign({}, styleProp, buildStyleProperty(motionValueStyles, !isStatic));\r\n};\r\nvar useMotionStyles = function (values, styleProp, transformValues) {\r\n    if (styleProp === void 0) { styleProp = {}; }\r\n    var style = useRef({}).current;\r\n    var prevMotionStyles = useRef({}).current;\r\n    var currentStyleKeys = new Set(Object.keys(style));\r\n    for (var key in styleProp) {\r\n        currentStyleKeys.delete(key);\r\n        var thisStyle = styleProp[key];\r\n        if (isMotionValue(thisStyle)) {\r\n            // If this is a motion value, add it to our MotionValuesMap\r\n            values.set(key, thisStyle);\r\n        }\r\n        else if (isTransformProp(key) || isTransformOriginProp(key)) {\r\n            // Or if it's a transform prop, create a motion value (or update an existing one)\r\n            // to ensure Stylefire can reconcile all the transform values together.\r\n            if (!values.has(key)) {\r\n                // If it doesn't exist as a motion value, create it\r\n                values.set(key, motionValue(thisStyle));\r\n            }\r\n            else {\r\n                // Otherwise only update it if it's changed from a previous render\r\n                if (thisStyle !== prevMotionStyles[key]) {\r\n                    var value = values.get(key);\r\n                    value.set(thisStyle);\r\n                }\r\n            }\r\n            prevMotionStyles[key] = thisStyle;\r\n        }\r\n        else {\r\n            style[key] = thisStyle;\r\n        }\r\n    }\r\n    currentStyleKeys.forEach(function (key) { return delete style[key]; });\r\n    return transformValues ? transformValues(style) : style;\r\n};\n\nvar isKeyframesTarget = function (v) {\r\n    return Array.isArray(v);\r\n};\n\nvar isCustomValue = function (v) {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nvar resolveFinalValueInKeyframes = function (v) {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\n\nvar auto = {\r\n    test: function (v) { return v === \"auto\"; },\r\n    parse: function (v) { return v; },\r\n};\r\nvar dimensionTypes = [number, px, percent, degrees, vw, vh, auto];\r\nvar valueTypes = dimensionTypes.concat([color, complex]);\r\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\r\nvar getDimensionValueType = function (v) {\r\n    return dimensionTypes.find(testValueType(v));\r\n};\r\nvar getValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\nvar underDampedSpring = function () { return ({\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restDelta: 0.5,\r\n    restSpeed: 10,\r\n}); };\r\nvar overDampedSpring = function (to) { return ({\r\n    type: \"spring\",\r\n    stiffness: 700,\r\n    damping: to === 0 ? 100 : 35,\r\n}); };\r\nvar linearTween = function () { return ({\r\n    ease: \"linear\",\r\n    duration: 0.3,\r\n}); };\r\nvar keyframes = function (values) { return ({\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n    values: values,\r\n}); };\r\nvar defaultTransitions = {\r\n    x: underDampedSpring,\r\n    y: underDampedSpring,\r\n    z: underDampedSpring,\r\n    rotate: underDampedSpring,\r\n    rotateX: underDampedSpring,\r\n    rotateY: underDampedSpring,\r\n    rotateZ: underDampedSpring,\r\n    scaleX: overDampedSpring,\r\n    scaleY: overDampedSpring,\r\n    scale: overDampedSpring,\r\n    opacity: linearTween,\r\n    backgroundColor: linearTween,\r\n    color: linearTween,\r\n    default: overDampedSpring,\r\n};\r\nvar getDefaultTransition = function (valueKey, to) {\r\n    var transitionFactory;\r\n    if (isKeyframesTarget(to)) {\r\n        transitionFactory = keyframes;\r\n    }\r\n    else {\r\n        transitionFactory =\r\n            defaultTransitions[valueKey] || defaultTransitions.default;\r\n    }\r\n    return __assign({ to: to }, transitionFactory(to));\r\n};\n\n/**\r\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\r\n * updates with `to` and then completes. By using this we can compose instant transitions\r\n * in with the same logic that applies `delay` or returns a `Promise` etc.\r\n *\r\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\r\n * the animation until after the duration finishes. This is for situations when you're **only**\r\n * animating non-animatable values and then setting something on `transitionEnd`. Really\r\n * you want this to fire after the \"animation\" finishes, rather than instantly.\r\n *\r\n * ```\r\n * animate={{\r\n *   display: 'block',\r\n *   transitionEnd: { display: 'none' }\r\n * }}\r\n * ```\r\n */\r\nvar just = function (_a) {\r\n    var to = _a.to, duration = _a.duration;\r\n    return action(function (_a) {\r\n        var update = _a.update, complete = _a.complete;\r\n        update(to);\r\n        duration ? delay(duration).start({ complete: complete }) : complete();\r\n    });\r\n};\n\nvar easingDefinitionToFunction = function (definition) {\r\n    if (Array.isArray(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\r\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\nvar isEasingArray = function (ease) {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\n\nvar isDurationAnimation = function (v) {\r\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\r\n};\n\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * : 100, \"100px\", \"#fff\"\r\n * : \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nvar isAnimatable = function (key, value) {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (key === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        complex.test(value) && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\n\n/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar transitions = { tween: tween, spring: spring, keyframes: keyframes$1, inertia: inertia, just: just };\r\nvar transitionOptionParser = {\r\n    tween: function (opts) {\r\n        if (opts.ease) {\r\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\r\n            opts.ease = easingDefinitionToFunction(ease);\r\n        }\r\n        return opts;\r\n    },\r\n    keyframes: function (_a) {\r\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\r\n        if (opts.values && opts.values[0] === null) {\r\n            var values = opts.values.slice();\r\n            values[0] = from;\r\n            opts.values = values;\r\n        }\r\n        if (opts.ease) {\r\n            opts.easings = isEasingArray(opts.ease)\r\n                ? opts.ease.map(easingDefinitionToFunction)\r\n                : easingDefinitionToFunction(opts.ease);\r\n        }\r\n        opts.ease = linear;\r\n        return opts;\r\n    },\r\n};\r\nvar isTransitionDefined = function (_a) {\r\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\r\n    return Object.keys(transition).length;\r\n};\r\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\r\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\r\n    // If no object, return default transition\r\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\r\n    // and see if there's any props remaining\r\n    if (transitionDefinition === undefined ||\r\n        !isTransitionDefined(transitionDefinition)) {\r\n        return __assign({ delay: delay }, getDefaultTransition(key, to));\r\n    }\r\n    var valueTransitionDefinition = transitionDefinition[key] ||\r\n        transitionDefinition.default ||\r\n        transitionDefinition;\r\n    if (valueTransitionDefinition.type === false) {\r\n        return {\r\n            type: \"just\",\r\n            delay: delay,\r\n            to: isKeyframesTarget(to)\r\n                ? to[to.length - 1]\r\n                : to,\r\n        };\r\n    }\r\n    else if (isKeyframesTarget(to)) {\r\n        return __assign({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition, { \r\n            // This animation must be keyframes if we're animating through an array\r\n            type: \"keyframes\" });\r\n    }\r\n    else {\r\n        return __assign({ type: \"tween\", to: to,\r\n            delay: delay }, valueTransitionDefinition);\r\n    }\r\n};\r\nvar preprocessOptions = function (type, opts) {\r\n    return transitionOptionParser[type]\r\n        ? transitionOptionParser[type](opts)\r\n        : opts;\r\n};\r\nvar getAnimation = function (key, value, target, transition) {\r\n    var origin = value.get();\r\n    var isOriginAnimatable = isAnimatable(key, origin);\r\n    var isTargetAnimatable = isAnimatable(key, target);\r\n    // TODO we could probably improve this check to ensure both values are of the same type -\r\n    // for instance 100 to #fff. This might live better in Popmotion.\r\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \" + target + \". \\\"\" + origin + \"\\\" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\r\n    // Parse the `transition` prop and return options for the Popmotion animation\r\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = __rest(_a, [\"type\"]);\r\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\r\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\r\n        ? transitions[type]\r\n        : just;\r\n    var opts = preprocessOptions(type, __assign({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\r\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\r\n    if (isDurationAnimation(opts)) {\r\n        if (opts.duration) {\r\n            opts.duration = secondsToMilliseconds(opts.duration);\r\n        }\r\n        if (opts.repeatDelay) {\r\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\r\n        }\r\n    }\r\n    return actionFactory(opts);\r\n};\r\n/**\r\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\r\n *\r\n * @internal\r\n */\r\nfunction startAnimation(key, value, target, _a) {\r\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = __rest(_a, [\"delay\"]);\r\n    return value.start(function (complete) {\r\n        var activeAnimation;\r\n        var animate = function () {\r\n            var animation = getAnimation(key, value, target, transition);\r\n            // Bind animation opts to animation\r\n            activeAnimation = animation.start({\r\n                update: function (v) { return value.set(v); },\r\n                complete: complete,\r\n            });\r\n        };\r\n        // If we're delaying this animation, only resolve it **after** the delay to\r\n        // ensure the value's resolve velocity is up-to-date.\r\n        if (delay$1) {\r\n            activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\r\n                complete: animate,\r\n            });\r\n        }\r\n        else {\r\n            animate();\r\n        }\r\n        return function () {\r\n            if (activeAnimation)\r\n                activeAnimation.stop();\r\n        };\r\n    });\r\n}\n\n/**\r\n * Get the current value of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getCurrent = function (values) {\r\n    var current = {};\r\n    values.forEach(function (value, key) { return (current[key] = value.get()); });\r\n    return current;\r\n};\r\n/**\r\n * Get the current velocity of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getVelocity = function (values) {\r\n    var velocity = {};\r\n    values.forEach(function (value, key) { return (velocity[key] = value.getVelocity()); });\r\n    return velocity;\r\n};\r\n/**\r\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\r\n * check, just helps with typing.\r\n * @param p -\r\n */\r\nvar isTargetResolver = function (p) {\r\n    return typeof p === \"function\";\r\n};\r\n/**\r\n * Check if value is a list of variant labels\r\n * @param v -\r\n */\r\nvar isVariantLabels = function (v) { return Array.isArray(v); };\r\n/**\r\n * Check if value is a numerical string, ie \"100\" or \"100px\"\r\n */\r\nvar isNumericalString = function (v) { return /^\\d*\\.?\\d+$/.test(v); };\r\n/**\r\n * Control animations for a single component\r\n * @internal\r\n */\r\nvar ValueAnimationControls = /** @class */ (function () {\r\n    function ValueAnimationControls(_a) {\r\n        var _this = this;\r\n        var values = _a.values, readValueFromSource = _a.readValueFromSource, makeTargetAnimatable = _a.makeTargetAnimatable;\r\n        /**\r\n         * The component's variants, as provided by `variants`\r\n         */\r\n        this.variants = {};\r\n        /**\r\n         * A set of values that we animate back to when a value is cleared of all overrides.\r\n         */\r\n        this.baseTarget = {};\r\n        /**\r\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\r\n         */\r\n        this.overrides = [];\r\n        /**\r\n         * A series of target overrides as they were originally resolved.\r\n         */\r\n        this.resolvedOverrides = [];\r\n        /**\r\n         * A Set of currently active override indexes\r\n         */\r\n        this.activeOverrides = new Set();\r\n        /**\r\n         * A Set of value keys that are currently animating.\r\n         */\r\n        this.isAnimating = new Set();\r\n        /**\r\n         * Check if the associated `MotionValueMap` has a key with the provided string.\r\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\r\n         */\r\n        this.hasValue = function (key) { return !_this.values.has(key); };\r\n        this.values = values;\r\n        this.readValueFromSource = readValueFromSource;\r\n        this.makeTargetAnimatable = makeTargetAnimatable;\r\n        this.values.forEach(function (value, key) { return (_this.baseTarget[key] = value.get()); });\r\n    }\r\n    /**\r\n     * Set the reference to the component's props.\r\n     * @param props -\r\n     */\r\n    ValueAnimationControls.prototype.setProps = function (props) {\r\n        this.props = props;\r\n    };\r\n    /**\r\n     * Set the reference to the component's variants\r\n     * @param variants -\r\n     */\r\n    ValueAnimationControls.prototype.setVariants = function (variants) {\r\n        if (variants)\r\n            this.variants = variants;\r\n    };\r\n    /**\r\n     * Set the component's default transition\r\n     * @param transition -\r\n     */\r\n    ValueAnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        if (transition)\r\n            this.defaultTransition = transition;\r\n    };\r\n    /**\r\n     * Set motion values without animation.\r\n     *\r\n     * @param target -\r\n     * @param isActive -\r\n     */\r\n    ValueAnimationControls.prototype.setValues = function (_a, _b) {\r\n        var _this = this;\r\n        var _c = _b === void 0 ? {} : _b, _d = _c.isActive, isActive = _d === void 0 ? new Set() : _d, priority = _c.priority;\r\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\r\n        target = this.transformValues(__assign({}, target, transitionEnd));\r\n        return Object.keys(target).forEach(function (key) {\r\n            if (isActive.has(key))\r\n                return;\r\n            isActive.add(key);\r\n            var targetValue = resolveFinalValueInKeyframes(target[key]);\r\n            if (_this.values.has(key)) {\r\n                var value = _this.values.get(key);\r\n                value && value.set(targetValue);\r\n            }\r\n            else {\r\n                _this.values.set(key, motionValue(targetValue));\r\n            }\r\n            if (!priority)\r\n                _this.baseTarget[key] = targetValue;\r\n        });\r\n    };\r\n    /**\r\n     * Allows `transformValues` to be set by a component that allows us to\r\n     * transform the values in a given `Target`. This allows Framer Library\r\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\r\n     * to manually support these extended types here in Framer Motion.\r\n     *\r\n     * @param values -\r\n     */\r\n    ValueAnimationControls.prototype.transformValues = function (values) {\r\n        var transformValues = this.props.transformValues;\r\n        return transformValues ? transformValues(values) : values;\r\n    };\r\n    /**\r\n     * Check a `Target` for new values we haven't animated yet, and add them\r\n     * to the `MotionValueMap`.\r\n     *\r\n     * Currently there's functionality here that is DOM-specific, we should allow\r\n     * this functionality to be injected by the factory that creates DOM-specific\r\n     * components.\r\n     *\r\n     * @param target -\r\n     */\r\n    ValueAnimationControls.prototype.checkForNewValues = function (target) {\r\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\r\n        var numNewValues = newValueKeys.length;\r\n        if (!numNewValues)\r\n            return;\r\n        for (var i = 0; i < numNewValues; i++) {\r\n            var key = newValueKeys[i];\r\n            var targetValue = target[key];\r\n            var value = null;\r\n            // If this is a keyframes value, we can attempt to use the first value in the\r\n            // array as that's going to be the first value of the animation anyway\r\n            if (Array.isArray(targetValue)) {\r\n                value = targetValue[0];\r\n            }\r\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\r\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\r\n            // or props.style (for HTML) if the value exists there before attempting to read.\r\n            if (value === null) {\r\n                value = this.readValueFromSource(key);\r\n                invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\r\n            }\r\n            if (typeof value === \"string\" && isNumericalString(value)) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!getValueType(value) && complex.test(targetValue)) {\r\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n                value = complex.getAnimatableNone(targetValue);\r\n            }\r\n            this.values.set(key, motionValue(value));\r\n            this.baseTarget[key] = value;\r\n        }\r\n    };\r\n    /**\r\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\r\n     * @param variant -\r\n     */\r\n    ValueAnimationControls.prototype.resolveVariant = function (variant) {\r\n        if (!variant) {\r\n            return {\r\n                target: undefined,\r\n                transition: undefined,\r\n                transitionEnd: undefined,\r\n            };\r\n        }\r\n        if (isTargetResolver(variant)) {\r\n            // resolve current and velocity\r\n            variant = variant(this.props.custom, getCurrent(this.values), getVelocity(this.values));\r\n        }\r\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = __rest(variant, [\"transition\", \"transitionEnd\"]);\r\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\r\n    };\r\n    /**\r\n     * Get the highest active override priority index\r\n     */\r\n    ValueAnimationControls.prototype.getHighestPriority = function () {\r\n        if (!this.activeOverrides.size)\r\n            return 0;\r\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\r\n    };\r\n    /**\r\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\r\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\r\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\r\n     * than the one that was resolved when the hover gesture animation started.\r\n     *\r\n     * @param definition -\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\r\n        this.overrides[overrideIndex] = definition;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) {\r\n                return child.setOverride(definition, overrideIndex);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Start an override animation.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.startOverride = function (overrideIndex) {\r\n        var override = this.overrides[overrideIndex];\r\n        if (override) {\r\n            return this.start(override, { priority: overrideIndex });\r\n        }\r\n    };\r\n    /**\r\n     * Clear an override. We check every value we animated to in this override to see if\r\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.clearOverride = function (overrideIndex) {\r\n        var _this = this;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\r\n        }\r\n        var override = this.overrides[overrideIndex];\r\n        if (!override)\r\n            return;\r\n        this.activeOverrides.delete(overrideIndex);\r\n        var highest = this.getHighestPriority();\r\n        this.resetIsAnimating();\r\n        if (highest) {\r\n            var highestOverride = this.overrides[highest];\r\n            highestOverride && this.startOverride(highest);\r\n        }\r\n        // Figure out which remaining values were affected by the override and animate those\r\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\r\n        if (!overrideTarget)\r\n            return;\r\n        var remainingValues = {};\r\n        for (var key in this.baseTarget) {\r\n            if (overrideTarget[key] !== undefined) {\r\n                remainingValues[key] = this.baseTarget[key];\r\n            }\r\n        }\r\n        this.onStart();\r\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\r\n    };\r\n    /**\r\n     * Apply a target/variant without any animation\r\n     */\r\n    ValueAnimationControls.prototype.apply = function (definition) {\r\n        if (Array.isArray(definition)) {\r\n            return this.applyVariantLabels(definition);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            return this.applyVariantLabels([definition]);\r\n        }\r\n        else {\r\n            this.setValues(definition);\r\n        }\r\n    };\r\n    /**\r\n     * Apply variant labels without animation\r\n     */\r\n    ValueAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\r\n        var _this = this;\r\n        var isActive = new Set();\r\n        var reversedList = variantLabelList.slice().reverse();\r\n        reversedList.forEach(function (key) {\r\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\r\n            if (transitionEnd) {\r\n                _this.setValues(transitionEnd, { isActive: isActive });\r\n            }\r\n            if (target) {\r\n                _this.setValues(target, { isActive: isActive });\r\n            }\r\n            if (_this.children && _this.children.size) {\r\n                _this.children.forEach(function (child) {\r\n                    return child.applyVariantLabels(variantLabelList);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.start = function (definition, opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        if (opts.priority) {\r\n            this.activeOverrides.add(opts.priority);\r\n        }\r\n        this.resetIsAnimating(opts.priority);\r\n        var animation;\r\n        if (isVariantLabels(definition)) {\r\n            animation = this.animateVariantLabels(definition, opts);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            animation = this.animateVariant(definition, opts);\r\n        }\r\n        else {\r\n            animation = this.animate(definition, opts);\r\n        }\r\n        this.onStart();\r\n        return animation.then(function () { return _this.onComplete(); });\r\n    };\r\n    ValueAnimationControls.prototype.animate = function (animationDefinition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\r\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\r\n        if (transitionOverride) {\r\n            transition = transitionOverride;\r\n        }\r\n        if (!target)\r\n            return Promise.resolve();\r\n        target = this.transformValues(target);\r\n        if (transitionEnd) {\r\n            transitionEnd = this.transformValues(transitionEnd);\r\n        }\r\n        this.checkForNewValues(target);\r\n        if (this.makeTargetAnimatable) {\r\n            var animatable = this.makeTargetAnimatable(target, transitionEnd);\r\n            target = animatable.target;\r\n            transitionEnd = animatable.transitionEnd;\r\n        }\r\n        if (priority) {\r\n            this.resolvedOverrides[priority] = target;\r\n        }\r\n        this.checkForNewValues(target);\r\n        var animations = [];\r\n        for (var key in target) {\r\n            var value = this.values.get(key);\r\n            if (!value || !target || target[key] === undefined)\r\n                continue;\r\n            var valueTarget = target[key];\r\n            if (!priority) {\r\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\r\n            }\r\n            if (this.isAnimating.has(key))\r\n                continue;\r\n            this.isAnimating.add(key);\r\n            animations.push(startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition)));\r\n        }\r\n        var allAnimations = Promise.all(animations);\r\n        return transitionEnd\r\n            ? allAnimations.then(function () {\r\n                _this.setValues(transitionEnd, { priority: priority });\r\n            })\r\n            : allAnimations;\r\n    };\r\n    ValueAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\r\n        var _this = this;\r\n        var animations = variantLabels.slice().reverse()\r\n            .map(function (label) { return _this.animateVariant(label, opts); });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\r\n        var _this = this;\r\n        var when = false;\r\n        var delayChildren = 0;\r\n        var staggerChildren = 0;\r\n        var staggerDirection = 1;\r\n        var priority = (opts && opts.priority) || 0;\r\n        var variant = this.variants[variantLabel];\r\n        var getAnimations = variant\r\n            ? function () { return _this.animate(variant, opts); }\r\n            : function () { return Promise.resolve(); };\r\n        var getChildrenAnimations = this.children\r\n            ? function () {\r\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\r\n            }\r\n            : function () { return Promise.resolve(); };\r\n        if (variant && this.children) {\r\n            var transition = this.resolveVariant(variant).transition;\r\n            if (transition) {\r\n                when = transition.when || when;\r\n                delayChildren = transition.delayChildren || delayChildren;\r\n                staggerChildren = transition.staggerChildren || staggerChildren;\r\n                staggerDirection =\r\n                    transition.staggerDirection || staggerDirection;\r\n            }\r\n        }\r\n        if (when) {\r\n            var _a = when === \"beforeChildren\"\r\n                ? [getAnimations, getChildrenAnimations]\r\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\r\n            return first().then(last);\r\n        }\r\n        else {\r\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\r\n        if (delayChildren === void 0) { delayChildren = 0; }\r\n        if (staggerChildren === void 0) { staggerChildren = 0; }\r\n        if (staggerDirection === void 0) { staggerDirection = 1; }\r\n        if (priority === void 0) { priority = 0; }\r\n        if (!this.children) {\r\n            return Promise.resolve();\r\n        }\r\n        var animations = [];\r\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\r\n        var generateStaggerDuration = staggerDirection === 1\r\n            ? function (i) { return i * staggerChildren; }\r\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\r\n        Array.from(this.children).forEach(function (childControls, i) {\r\n            var animation = childControls.animateVariant(variantLabel, {\r\n                priority: priority,\r\n                delay: delayChildren + generateStaggerDuration(i),\r\n            });\r\n            animations.push(animation);\r\n        });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.onStart = function () {\r\n        var onAnimationStart = this.props.onAnimationStart;\r\n        onAnimationStart && onAnimationStart();\r\n    };\r\n    ValueAnimationControls.prototype.onComplete = function () {\r\n        var onAnimationComplete = this.props.onAnimationComplete;\r\n        onAnimationComplete && onAnimationComplete();\r\n    };\r\n    ValueAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\r\n        var numOverrides = this.overrides.length;\r\n        for (var i = priority + 1; i < numOverrides; i++) {\r\n            var resolvedOverride = this.resolvedOverrides[i];\r\n            if (resolvedOverride) {\r\n                for (var key in resolvedOverride) {\r\n                    this.isAnimating.add(key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.resetIsAnimating = function (priority) {\r\n        if (priority === void 0) { priority = 0; }\r\n        this.isAnimating.clear();\r\n        // If this isn't the highest priority gesture, block the animation\r\n        // of anything that's currently being animated\r\n        if (priority < this.getHighestPriority()) {\r\n            this.checkOverrideIsAnimating(priority);\r\n        }\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.stop = function () {\r\n        this.values.forEach(function (value) { return value.stop(); });\r\n    };\r\n    /**\r\n     * Add the controls of a child component.\r\n     * @param controls -\r\n     */\r\n    ValueAnimationControls.prototype.addChild = function (controls) {\r\n        if (!this.children) {\r\n            this.children = new Set();\r\n        }\r\n        this.children.add(controls);\r\n        // We set child overrides when `setOverride` is called, but also have to do it here\r\n        // as the first time `setOverride` is called all the children might not have been added yet.\r\n        this.overrides.forEach(function (override, i) {\r\n            override && controls.setOverride(override, i);\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.removeChild = function (controls) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(controls);\r\n    };\r\n    ValueAnimationControls.prototype.resetChildren = function () {\r\n        if (this.children)\r\n            this.children.clear();\r\n    };\r\n    return ValueAnimationControls;\r\n}());\n\n/**\r\n * Use a callback a maximum number of times\r\n * @param callback - Callback to run\r\n * @param times - Maximum number of times to run the callback. Defaults to `1`\r\n *\r\n * @public\r\n */\r\nfunction useMaxTimes(callback, times) {\r\n    if (times === void 0) { times = 1; }\r\n    var count = useRef(0);\r\n    if (count.current++ < times)\r\n        callback();\r\n}\n\n/**\r\n * Control animations on one or more components.\r\n *\r\n * @public\r\n */\r\nvar AnimationControls = /** @class */ (function () {\r\n    function AnimationControls() {\r\n        /**\r\n         * Track whether the host component has mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.hasMounted = false;\r\n        /**\r\n         * Pending animations that are started before a component is mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.pendingAnimations = [];\r\n        /**\r\n         * A collection of linked component animation controls.\r\n         *\r\n         * @internal\r\n         */\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Set variants on this and all child components.\r\n     *\r\n     * @param variants - The variants to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setVariants = function (variants) {\r\n        this.variants = variants;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setVariants(variants);\r\n        });\r\n    };\r\n    /**\r\n     * Set a default transition on this and all child components\r\n     *\r\n     * @param transition - The default transition to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        this.defaultTransition = transition;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setDefaultTransition(transition);\r\n        });\r\n    };\r\n    /**\r\n     * Subscribes a component's animation controls to this.\r\n     *\r\n     * @param controls - The controls to subscribe\r\n     * @returns An unsubscribe function.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        if (this.variants)\r\n            controls.setVariants(this.variants);\r\n        if (this.defaultTransition)\r\n            controls.setDefaultTransition(this.defaultTransition);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Starts an animation on all linked components.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * controls.start(\"variantLabel\")\r\n     * controls.start({\r\n     *   x: 0,\r\n     *   transition: { duration: 1 }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param definition - Properties or variant label to animate to\r\n     * @param transition - Optional `transtion` to apply to a variant\r\n     * @returns - A `Promise` that resolves when all animations have completed.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\r\n        var _this = this;\r\n        if (this.hasMounted) {\r\n            var animations_1 = [];\r\n            this.componentControls.forEach(function (controls) {\r\n                var animation = controls.start(definition, {\r\n                    transitionOverride: transitionOverride,\r\n                });\r\n                animations_1.push(animation);\r\n            });\r\n            return Promise.all(animations_1);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve) {\r\n                _this.pendingAnimations.push({\r\n                    animation: [definition, transitionOverride],\r\n                    resolve: resolve,\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Instantly set to a set of properties or a variant.\r\n     *\r\n     * ```jsx\r\n     * // With properties\r\n     * controls.set({ opacity: 0 })\r\n     *\r\n     * // With variants\r\n     * controls.set(\"hidden\")\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     * We could perform a similar trick to `.start` where this can be called before mount\r\n     * and we maintain a list of of pending actions that get applied on mount. But the\r\n     * expectation of `set` is that it happens synchronously and this would be difficult\r\n     * to do before any children have even attached themselves. It's also poor practise\r\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.set = function (definition) {\r\n        invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n        return this.componentControls.forEach(function (controls) {\r\n            return controls.apply(definition);\r\n        });\r\n    };\r\n    /**\r\n     * Stops animations on all linked components.\r\n     *\r\n     * ```jsx\r\n     * controls.stop()\r\n     * ```\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.stop = function () {\r\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\r\n    };\r\n    /**\r\n     * Initialises the animation controls.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.mount = function () {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        this.pendingAnimations.forEach(function (_a) {\r\n            var animation = _a.animation, resolve = _a.resolve;\r\n            return _this.start.apply(_this, animation).then(resolve);\r\n        });\r\n    };\r\n    /**\r\n     * Stops all child animations when the host component unmounts.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.unmount = function () {\r\n        this.hasMounted = false;\r\n        this.stop();\r\n    };\r\n    return AnimationControls;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nvar animationControls = function () { return new AnimationControls(); };\n\n/**\r\n * @internal\r\n */\r\nvar MotionContext = createContext({\r\n    static: false,\r\n});\r\nvar isVariantLabel = function (v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n};\r\nvar isAnimationControls = function (v) {\r\n    return v instanceof AnimationControls;\r\n};\r\n/**\r\n * Set up the context for children motion components.\r\n *\r\n * We also use this opportunity to apply `initial` values\r\n */\r\nvar useMotionContext = function (parentContext, controls, values, isStatic, _a) {\r\n    if (isStatic === void 0) { isStatic = false; }\r\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover;\r\n    var initialState;\r\n    if (initial === false && !isAnimationControls(animate)) {\r\n        initialState = animate;\r\n    }\r\n    else if (typeof initial !== \"boolean\") {\r\n        initialState = initial;\r\n    }\r\n    // Track mounted status so children can detect whether they were present during their\r\n    // parent's first render\r\n    var hasMounted = useRef(false);\r\n    // We propagate this component's ValueAnimationControls *if* we're being provided variants,\r\n    // if we're being used to control variants, or if we're being passed animation controls.\r\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\r\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\r\n    // that this restriction is removed.\r\n    var shouldPropagateControls = variants ||\r\n        isVariantLabel(animate) ||\r\n        isVariantLabel(whileTap) ||\r\n        isVariantLabel(whileHover) ||\r\n        isAnimationControls(animate);\r\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\r\n    var targetInitial = isVariantLabel(initialState)\r\n        ? initialState\r\n        : parentContext.initial;\r\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\r\n    // the tree initially animates.\r\n    var targetAnimate = isVariantLabel(animate)\r\n        ? animate\r\n        : parentContext.animate;\r\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\r\n    // or in another non-animation/interaction environment.\r\n    var initialDependency = isStatic ? targetInitial : null;\r\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\r\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\r\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\r\n    // the new order of any child components for the `staggerChildren` functionality.\r\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\r\n        ? targetAnimate\r\n        : null;\r\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\r\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\r\n    // So all child motion components will re-render as a result.\r\n    var context = useMemo(function () { return ({\r\n        controls: shouldPropagateControls\r\n            ? controls\r\n            : parentContext.controls,\r\n        initial: targetInitial,\r\n        animate: targetAnimate,\r\n        values: values,\r\n        hasMounted: hasMounted,\r\n    }); }, [initialDependency, animateDependency]);\r\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\r\n    context.static = isStatic;\r\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\r\n    // in `initial`.\r\n    useMaxTimes(function () {\r\n        var initialToApply = initialState || parentContext.initial;\r\n        initialToApply && controls.apply(initialToApply);\r\n    }, isStatic ? Infinity : 1);\r\n    useEffect(function () {\r\n        hasMounted.current = true;\r\n    }, []);\r\n    return context;\r\n};\n\n/**\r\n * Creates an imperative set of controls to trigger animations.\r\n *\r\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\r\n *\r\n * @param values\r\n * @param props\r\n * @param ref\r\n * @param subscribeToParentControls\r\n *\r\n * @internal\r\n */\r\nfunction useValueAnimationControls(config, props, subscribeToParentControls) {\r\n    var variants = props.variants, transition = props.transition;\r\n    var parentControls = useContext(MotionContext).controls;\r\n    var controls = useConstant(function () { return new ValueAnimationControls(config); });\r\n    // Reset and resubscribe children every render to ensure stagger order is correct\r\n    controls.resetChildren();\r\n    controls.setProps(props);\r\n    controls.setVariants(variants);\r\n    controls.setDefaultTransition(transition);\r\n    if (subscribeToParentControls && parentControls) {\r\n        parentControls.addChild(controls);\r\n    }\r\n    useEffect(function () { return function () {\r\n        // Remove reference to onAnimationComplete from controls. All the MotionValues\r\n        // are unsubscribed from this component separately. We let animations run out\r\n        // as they might be animating other components.\r\n        var onAnimationComplete = props.onAnimationComplete, unmountProps = __rest(props, [\"onAnimationComplete\"]);\r\n        controls.setProps(unmountProps);\r\n        parentControls && parentControls.removeChild(controls);\r\n    }; }, []);\r\n    return controls;\r\n}\n\nfunction applyExitProps(props, _a) {\r\n    var initial = _a.initial, isExiting = _a.isExiting, custom = _a.custom, onExitComplete = _a.onExitComplete;\r\n    if (isExiting) {\r\n        invariant(!!props.exit, \"No exit animation defined.\");\r\n        return __assign({}, props, { \r\n            /**\r\n             * Overwrite user-defined `custom` with the one incoming from `AnimatePresence`.\r\n             * This will only be defined when a component is exiting and it allows a user\r\n             * to update `custom` even when a component has been removed from the tree.\r\n             */\r\n            custom: custom !== undefined ? custom : props.custom, \r\n            // Animate to `exit` just by overwriting `animate`.\r\n            animate: props.exit, onAnimationComplete: function () {\r\n                onExitComplete && onExitComplete();\r\n                props.onAnimationComplete && props.onAnimationComplete();\r\n            } });\r\n    }\r\n    else if (initial === false) {\r\n        return __assign({}, props, { initial: initial });\r\n    }\r\n    return props;\r\n}\n\nvar checkShouldInheritVariant = function (_a) {\r\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\r\n    return (inherit &&\r\n        !!variants &&\r\n        (!animate || animate instanceof AnimationControls));\r\n};\n\n/**\r\n * @internal\r\n */\r\nvar createMotionComponent = function (_a) {\r\n    var getValueControlsConfig = _a.getValueControlsConfig, loadFunctionalityComponents = _a.loadFunctionalityComponents, renderComponent = _a.renderComponent;\r\n    function MotionComponent(props, externalRef) {\r\n        var ref = useExternalRef(externalRef);\r\n        var _a = useContext(MotionContext), exitProps = _a.exitProps, parentContext = __rest(_a, [\"exitProps\"]);\r\n        if (exitProps) {\r\n            props = applyExitProps(props, exitProps);\r\n        }\r\n        var isStatic = parentContext.static || props.static || false;\r\n        var values = useMotionValues(props);\r\n        var style = useMotionStyles(values, props.style, props.transformValues);\r\n        var shouldInheritVariant = checkShouldInheritVariant(props);\r\n        var controlsConfig = useConstant(function () {\r\n            return getValueControlsConfig(ref, values);\r\n        });\r\n        var controls = useValueAnimationControls(controlsConfig, props, shouldInheritVariant);\r\n        var context = useMotionContext(parentContext, controls, values, isStatic, props);\r\n        var functionality = isStatic\r\n            ? null\r\n            : loadFunctionalityComponents(ref, values, props, controls, shouldInheritVariant);\r\n        var renderedComponent = renderComponent(ref, style, values, props, isStatic);\r\n        return (createElement(Fragment, null,\r\n            createElement(MountMotionValues, { ref: ref, values: values, isStatic: isStatic }),\r\n            functionality,\r\n            createElement(MotionContext.Provider, { value: context }, renderedComponent)));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n};\n\n/**\r\n * @internal\r\n */\r\nvar htmlElements = [\r\n    \"a\",\r\n    \"abbr\",\r\n    \"address\",\r\n    \"area\",\r\n    \"article\",\r\n    \"aside\",\r\n    \"audio\",\r\n    \"b\",\r\n    \"base\",\r\n    \"bdi\",\r\n    \"bdo\",\r\n    \"big\",\r\n    \"blockquote\",\r\n    \"body\",\r\n    \"br\",\r\n    \"button\",\r\n    \"canvas\",\r\n    \"caption\",\r\n    \"cite\",\r\n    \"code\",\r\n    \"col\",\r\n    \"colgroup\",\r\n    \"data\",\r\n    \"datalist\",\r\n    \"dd\",\r\n    \"del\",\r\n    \"details\",\r\n    \"dfn\",\r\n    \"dialog\",\r\n    \"div\",\r\n    \"dl\",\r\n    \"dt\",\r\n    \"em\",\r\n    \"embed\",\r\n    \"fieldset\",\r\n    \"figcaption\",\r\n    \"figure\",\r\n    \"footer\",\r\n    \"form\",\r\n    \"h1\",\r\n    \"h2\",\r\n    \"h3\",\r\n    \"h4\",\r\n    \"h5\",\r\n    \"h6\",\r\n    \"head\",\r\n    \"header\",\r\n    \"hgroup\",\r\n    \"hr\",\r\n    \"html\",\r\n    \"i\",\r\n    \"iframe\",\r\n    \"img\",\r\n    \"input\",\r\n    \"ins\",\r\n    \"kbd\",\r\n    \"keygen\",\r\n    \"label\",\r\n    \"legend\",\r\n    \"li\",\r\n    \"link\",\r\n    \"main\",\r\n    \"map\",\r\n    \"mark\",\r\n    \"menu\",\r\n    \"menuitem\",\r\n    \"meta\",\r\n    \"meter\",\r\n    \"nav\",\r\n    \"noscript\",\r\n    \"object\",\r\n    \"ol\",\r\n    \"optgroup\",\r\n    \"option\",\r\n    \"output\",\r\n    \"p\",\r\n    \"param\",\r\n    \"picture\",\r\n    \"pre\",\r\n    \"progress\",\r\n    \"q\",\r\n    \"rp\",\r\n    \"rt\",\r\n    \"ruby\",\r\n    \"s\",\r\n    \"samp\",\r\n    \"script\",\r\n    \"section\",\r\n    \"select\",\r\n    \"small\",\r\n    \"source\",\r\n    \"span\",\r\n    \"strong\",\r\n    \"style\",\r\n    \"sub\",\r\n    \"summary\",\r\n    \"sup\",\r\n    \"table\",\r\n    \"tbody\",\r\n    \"td\",\r\n    \"textarea\",\r\n    \"tfoot\",\r\n    \"th\",\r\n    \"thead\",\r\n    \"time\",\r\n    \"title\",\r\n    \"tr\",\r\n    \"track\",\r\n    \"u\",\r\n    \"ul\",\r\n    \"var\",\r\n    \"video\",\r\n    \"wbr\",\r\n    \"webview\",\r\n];\r\n/**\r\n * @internal\r\n */\r\nvar svgElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"svg\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\n\n/** @public */\r\nvar Point;\r\n(function (Point) {\r\n    /** @beta */\r\n    Point.subtract = function (a, b) {\r\n        return { x: a.x - b.x, y: a.y - b.y };\r\n    };\r\n    /** @beta */\r\n    Point.relativeTo = function (idOrElem) {\r\n        var elem;\r\n        var getElem = function () {\r\n            // Caching element here could be leaky because of React lifecycle\r\n            if (elem !== undefined)\r\n                return elem;\r\n            if (typeof idOrElem === \"string\") {\r\n                elem = document.getElementById(idOrElem);\r\n            }\r\n            else {\r\n                elem = idOrElem;\r\n            }\r\n            return elem;\r\n        };\r\n        return function (_a) {\r\n            var x = _a.x, y = _a.y;\r\n            var localElem = getElem();\r\n            if (!localElem)\r\n                return undefined;\r\n            var rect = localElem.getBoundingClientRect();\r\n            return {\r\n                x: x - rect.left - window.scrollX,\r\n                y: y - rect.top - window.scrollY,\r\n            };\r\n        };\r\n    };\r\n})(Point || (Point = {}));\n\n/**\r\n * @internal\r\n */\r\nvar MotionPluginContext = createContext({\r\n    transformPagePoint: function (p) { return p; },\r\n});\r\n/**\r\n * @internal\r\n * @internalremarks For now I think this should remain a private API for our own use\r\n * until we can figure out a nicer way of allowing people to add these\r\n */\r\nfunction MotionPlugins(_a) {\r\n    var children = _a.children, props = __rest(_a, [\"children\"]);\r\n    var pluginContext = useContext(MotionPluginContext);\r\n    var value = useRef(__assign({}, pluginContext)).current;\r\n    // Mutative to prevent triggering rerenders in all listening\r\n    // components every time this component renders\r\n    for (var key in props) {\r\n        value[key] = props[key];\r\n    }\r\n    return (createElement(MotionPluginContext.Provider, { value: value }, children));\r\n}\n\nvar isViewportScrollBlocked = false;\r\nvar isBrowser = typeof window !== \"undefined\";\r\nif (isBrowser) {\r\n    window.addEventListener(\"touchmove\", function (event) {\r\n        if (isViewportScrollBlocked) {\r\n            event.preventDefault();\r\n        }\r\n    }, { passive: false });\r\n}\r\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\r\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\n\nfunction isMouseEvent(event) {\r\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\r\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\r\n        return !!(event.pointerType === \"mouse\");\r\n    }\r\n    return event instanceof MouseEvent;\r\n}\r\nfunction isTouchEvent(event) {\r\n    var hasTouches = !!event.touches;\r\n    return hasTouches;\r\n}\n\nfunction useUnmountEffect(callback) {\r\n    return useEffect(function () { return function () { return callback(); }; }, []);\r\n}\n\nfunction addDomEvent(target, eventName, handler, options) {\r\n    if (!handler)\r\n        return;\r\n    target.addEventListener(eventName, handler, options);\r\n    return function () { return target.removeEventListener(eventName, handler, options); };\r\n}\r\n/**\r\n * Attaches an event listener directly to the provided DOM element.\r\n *\r\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\r\n * event handlers.\r\n *\r\n * ```jsx\r\n * const ref = useRef(null)\r\n *\r\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\r\n *\r\n * return <div ref={ref} />\r\n * ```\r\n *\r\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\r\n * @param eventName - Name of the event you want listen for.\r\n * @param handler - Function to fire when receiving the event.\r\n * @param options - Options to pass to `Event.addEventListener`.\r\n *\r\n * @public\r\n */\r\nfunction useDomEvent(ref, eventName, handler, options) {\r\n    useEffect(function () {\r\n        var element = ref.current;\r\n        if (handler && element) {\r\n            return addDomEvent(element, eventName, handler, options);\r\n        }\r\n    }, [ref, eventName, handler, options]);\r\n}\n\n/**\r\n * Filters out events not attached to the primary pointer (currently left mouse button)\r\n * @param eventHandler\r\n */\r\nfunction filterPrimaryPointer(eventHandler) {\r\n    if (!eventHandler)\r\n        return undefined;\r\n    return function (event) {\r\n        var isMouseEvent = event instanceof MouseEvent;\r\n        var isPrimaryPointer = !isMouseEvent ||\r\n            (isMouseEvent && event.button === 0);\r\n        if (isPrimaryPointer) {\r\n            eventHandler(event);\r\n        }\r\n    };\r\n}\r\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\r\nfunction pointFromTouch(e) {\r\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\r\n    var _a = primaryTouch || defaultPagePoint, pageX = _a.pageX, pageY = _a.pageY;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction pointFromMouse(_a) {\r\n    var _b = _a.pageX, pageX = _b === void 0 ? 0 : _b, _c = _a.pageY, pageY = _c === void 0 ? 0 : _c;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction extractEventInfo(event) {\r\n    return {\r\n        point: isTouchEvent(event)\r\n            ? pointFromTouch(event)\r\n            : pointFromMouse(event),\r\n    };\r\n}\r\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\r\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\r\n    if (!handler)\r\n        return;\r\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\r\n    return shouldFilterPrimaryPointer\r\n        ? filterPrimaryPointer(listener)\r\n        : listener;\r\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\r\nvar isBrowser$1 = typeof window !== \"undefined\";\r\nvar supportsPointerEvents = function () { return isBrowser$1 && window.onpointerdown === null; };\r\nvar supportsTouchEvents = function () { return isBrowser$1 && window.ontouchstart === null; };\r\nvar supportsMouseEvents = function () { return isBrowser$1 && window.onmousedown === null; };\r\nvar mouseEventNames = {\r\n    pointerdown: \"mousedown\",\r\n    pointermove: \"mousemove\",\r\n    pointerup: \"mouseup\",\r\n    pointercancel: \"mousecancel\",\r\n    pointerover: \"mouseover\",\r\n    pointerout: \"mouseout\",\r\n    pointerenter: \"mouseenter\",\r\n    pointerleave: \"mouseleave\",\r\n};\r\nvar touchEventNames = {\r\n    pointerdown: \"touchstart\",\r\n    pointermove: \"touchmove\",\r\n    pointerup: \"touchend\",\r\n    pointercancel: \"touchcancel\",\r\n};\r\nfunction getPointerEventName(name) {\r\n    if (supportsPointerEvents()) {\r\n        return name;\r\n    }\r\n    else if (supportsTouchEvents()) {\r\n        return touchEventNames[name];\r\n    }\r\n    else if (supportsMouseEvents()) {\r\n        return mouseEventNames[name];\r\n    }\r\n    return name;\r\n}\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\r\nfunction usePointerEvent(ref, eventName, handler, options) {\r\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\n\nfunction startDevicePoint(session) {\r\n    return session.pointHistory[0];\r\n}\r\nfunction lastDevicePoint(session) {\r\n    return session.pointHistory[session.pointHistory.length - 1];\r\n}\r\nfunction getVelocity$1(session, timeDelta) {\r\n    var pointHistory = session.pointHistory;\r\n    if (pointHistory.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var i = pointHistory.length - 1;\r\n    var timestampedPoint = null;\r\n    var lastPoint = lastDevicePoint(session);\r\n    while (i >= 0) {\r\n        timestampedPoint = pointHistory[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\r\n/**\r\n *\r\n * @param handlers -\r\n * @param ref -\r\n *\r\n * @internalremarks\r\n * Currently this sets new pan gesture functions every render. The memo route has been explored\r\n * in the past but ultimately we're still creating new functions every render. An optimisation\r\n * to explore is creating the pan gestures and loading them into a `ref`.\r\n *\r\n * @internal\r\n */\r\nfunction usePanGesture(_a, ref) {\r\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\r\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\r\n    var session = useRef(null);\r\n    var lastMoveEvent = useRef(null);\r\n    var lastMoveEventInfo = useRef(null);\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    var pointerEventSubscription = useRef(null);\r\n    // Load the callbacks into mutable state to ensure that even if we don't create a new\r\n    // gesture handler every render, we still reference the latest callbacks (which are almost certain to change per render)\r\n    var handlers = useRef({}).current;\r\n    handlers.onPanSessionStart = onPanSessionStart;\r\n    handlers.onPanStart = onPanStart;\r\n    handlers.onPan = onPan;\r\n    handlers.onPanEnd = onPanEnd;\r\n    function removePointerEvents() {\r\n        pointerEventSubscription.current && pointerEventSubscription.current();\r\n        pointerEventSubscription.current = null;\r\n    }\r\n    function getPanInfo(_a) {\r\n        var point = _a.point;\r\n        var currentPoint = session.current;\r\n        // TODO: A potential optimisation here that might be a breaking change would be\r\n        // to keep one mutable ref to a point that we update\r\n        return {\r\n            point: point,\r\n            delta: Point.subtract(point, lastDevicePoint(currentPoint)),\r\n            offset: Point.subtract(point, startDevicePoint(currentPoint)),\r\n            velocity: getVelocity$1(currentPoint, 0.1),\r\n        };\r\n    }\r\n    function transformPoint(info) {\r\n        return { point: transformPagePoint(info.point) };\r\n    }\r\n    function cancelPan() {\r\n        removePointerEvents();\r\n        cancelSync.update(updatePoint);\r\n        unblockViewportScroll();\r\n    }\r\n    function updatePoint() {\r\n        if (!session.current ||\r\n            !lastMoveEvent.current ||\r\n            !lastMoveEventInfo.current) {\r\n            warning(false, \"onPointerMove fired without pointer session\");\r\n            cancelPan();\r\n            return;\r\n        }\r\n        var info = getPanInfo(lastMoveEventInfo.current);\r\n        var panStarted = session.current.startEvent !== undefined;\r\n        // Only start panning if the offset is larger than 3 pixels. If we make it\r\n        // any larger than this we'll want to reset the pointer history\r\n        // on the first update to avoid visual snapping to the cursoe.\r\n        var distancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\r\n        if (!panStarted && !distancePastThreshold)\r\n            return;\r\n        var point = info.point;\r\n        var timestamp = getFrameData().timestamp;\r\n        session.current.pointHistory.push(__assign({}, point, { timestamp: timestamp }));\r\n        if (!panStarted) {\r\n            handlers.onPanStart &&\r\n                handlers.onPanStart(lastMoveEvent.current, info);\r\n            session.current.startEvent = lastMoveEvent.current;\r\n        }\r\n        handlers.onPan && handlers.onPan(lastMoveEvent.current, info);\r\n    }\r\n    function onPointerMove(event, info) {\r\n        lastMoveEvent.current = event;\r\n        lastMoveEventInfo.current = transformPoint(info);\r\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\r\n        if (isMouseEvent(event) && event.buttons === 0) {\r\n            onPointerUp(event, info);\r\n            return;\r\n        }\r\n        // Throttle mouse move event to once per frame\r\n        sync.update(updatePoint, true);\r\n    }\r\n    function onPointerUp(event, info) {\r\n        cancelPan();\r\n        if (!session.current) {\r\n            warning(false, \"onPointerUp fired without pointer session\");\r\n            return;\r\n        }\r\n        handlers.onPanEnd &&\r\n            handlers.onPanEnd(event, getPanInfo(transformPoint(info)));\r\n        session.current = null;\r\n    }\r\n    function onPointerDown(event, info) {\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (isTouchEvent(event) && event.touches.length > 1)\r\n            return;\r\n        var initialInfo = transformPoint(info);\r\n        var point = initialInfo.point;\r\n        var timestamp = getFrameData().timestamp;\r\n        session.current = {\r\n            target: event.target,\r\n            pointHistory: [__assign({}, point, { timestamp: timestamp })],\r\n        };\r\n        handlers.onPanSessionStart &&\r\n            handlers.onPanSessionStart(event, getPanInfo(initialInfo));\r\n        removePointerEvents();\r\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", onPointerMove);\r\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", onPointerUp);\r\n        pointerEventSubscription.current = function () {\r\n            removeOnPointerMove && removeOnPointerMove();\r\n            removeOnPointerUp && removeOnPointerUp();\r\n        };\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\r\n    useUnmountEffect(cancelPan);\r\n}\n\n/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nvar isNodeOrChild = function (parent, child) {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\n\nvar order = [\"whileHover\", \"whileTap\", \"whileDrag\"];\r\nvar getGesturePriority = function (gesture) {\r\n    return order.indexOf(gesture) + 1;\r\n};\n\nfunction createLock(name) {\r\n    var lock = null;\r\n    return function () {\r\n        var openLock = function () {\r\n            lock = null;\r\n        };\r\n        if (lock === null) {\r\n            lock = name;\r\n            return openLock;\r\n        }\r\n        return false;\r\n    };\r\n}\r\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\r\nvar globalVerticalLock = createLock(\"dragVertical\");\r\nfunction getGlobalLock(drag) {\r\n    var lock = false;\r\n    if (drag === \"y\") {\r\n        lock = globalVerticalLock();\r\n    }\r\n    else if (drag === \"x\") {\r\n        lock = globalHorizontalLock();\r\n    }\r\n    else {\r\n        var openHorizontal_1 = globalHorizontalLock();\r\n        var openVertical_1 = globalVerticalLock();\r\n        if (openHorizontal_1 && openVertical_1) {\r\n            lock = function () {\r\n                openHorizontal_1();\r\n                openVertical_1();\r\n            };\r\n        }\r\n        else {\r\n            // Release the locks because we don't use them\r\n            if (openHorizontal_1)\r\n                openHorizontal_1();\r\n            if (openVertical_1)\r\n                openVertical_1();\r\n        }\r\n    }\r\n    return lock;\r\n}\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\r\n/**\r\n * @param handlers -\r\n * @internal\r\n */\r\nfunction useTapGesture(_a, ref) {\r\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\r\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\r\n    var isTapping = useRef(false);\r\n    var cancelPointerEventListener = useRef(null);\r\n    function removePointerUp() {\r\n        cancelPointerEventListener.current &&\r\n            cancelPointerEventListener.current();\r\n        cancelPointerEventListener.current = null;\r\n    }\r\n    if (whileTap && controls) {\r\n        controls.setOverride(whileTap, tapGesturePriority);\r\n    }\r\n    // We load this event handler into a ref so we can later refer to\r\n    // onPointerUp.current which will always have reference to the latest props\r\n    var onPointerUp = useRef(null);\r\n    onPointerUp.current = function (event, info) {\r\n        var element = ref.current;\r\n        removePointerUp();\r\n        if (!isTapping.current || !element)\r\n            return;\r\n        isTapping.current = false;\r\n        if (controls && whileTap) {\r\n            controls.clearOverride(tapGesturePriority);\r\n        }\r\n        // Check the gesture lock - if we get it, it means no drag gesture is active\r\n        // and we can safely fire the tap gesture.\r\n        var openGestureLock = getGlobalLock(true);\r\n        if (!openGestureLock)\r\n            return;\r\n        openGestureLock();\r\n        if (!isNodeOrChild(element, event.target)) {\r\n            onTapCancel && onTapCancel(event, info);\r\n        }\r\n        else {\r\n            onTap && onTap(event, info);\r\n        }\r\n    };\r\n    function onPointerDown(event, info) {\r\n        removePointerUp();\r\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\r\n        var element = ref.current;\r\n        if (!element || isTapping.current)\r\n            return;\r\n        isTapping.current = true;\r\n        onTapStart && onTapStart(event, info);\r\n        if (controls && whileTap) {\r\n            controls.startOverride(tapGesturePriority);\r\n        }\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\r\n    useUnmountEffect(removePointerUp);\r\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\r\nvar filterTouch = function (listener) { return function (event, info) {\r\n    if (isMouseEvent(event))\r\n        listener(event, info);\r\n}; };\r\n/**\r\n *\r\n * @param props\r\n * @param ref\r\n * @internal\r\n */\r\nfunction useHoverGesture(_a, ref) {\r\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\r\n    if (whileHover && controls) {\r\n        controls.setOverride(whileHover, hoverPriority);\r\n    }\r\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\r\n        if (onHoverStart)\r\n            onHoverStart(event, info);\r\n        if (whileHover && controls) {\r\n            controls.startOverride(hoverPriority);\r\n        }\r\n    }));\r\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\r\n        if (onHoverEnd)\r\n            onHoverEnd(event, info);\r\n        if (whileHover && controls) {\r\n            controls.clearOverride(hoverPriority);\r\n        }\r\n    }));\r\n}\n\n/**\r\n * Add pan and tap gesture recognition to an element.\r\n *\r\n * @param props - Gesture event handlers\r\n * @param ref - React `ref` containing a DOM `Element`\r\n * @public\r\n */\r\nfunction useGestures(props, ref) {\r\n    usePanGesture(props, ref);\r\n    useTapGesture(props, ref);\r\n    useHoverGesture(props, ref);\r\n}\n\nvar makeHookComponent = function (hook) { return function (props) {\r\n    hook(props);\r\n    return null;\r\n}; };\n\nvar gestureProps = [\r\n    \"drag\",\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileTap\",\r\n    \"whileHover\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n];\r\nvar Gestures = {\r\n    key: \"gestures\",\r\n    shouldRender: function (props) {\r\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\r\n    },\r\n    Component: makeHookComponent(function (_a) {\r\n        var innerRef = _a.innerRef, props = __rest(_a, [\"innerRef\"]);\r\n        useGestures(props, innerRef);\r\n    }),\r\n};\n\nvar isRefObject = function (ref) {\r\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\r\n};\n\n/**\r\n * A hook to use the window resize listener. In future it might be cool to use `ResizeObserver`\r\n * but it currently needs to be polyfilled and the size trade-off isn't there for this use-case.\r\n *\r\n * TODO: Debounce this bad boy\r\n *\r\n * @param onResize\r\n */\r\nfunction useResize(element, onResize) {\r\n    useEffect(function () {\r\n        if (!element || !isRefObject(element))\r\n            return;\r\n        window.addEventListener(\"resize\", onResize);\r\n        return function () { return window.removeEventListener(\"resize\", onResize); };\r\n    }, [element, onResize]);\r\n}\n\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    return useConstant(function () { return motionValue(initial); });\r\n}\n\n/**\r\n * Don't block the default pointerdown behaviour of these elements.\r\n */\r\nvar allowDefaultPointerDown = new Set([\"INPUT\", \"TEXTAREA\", \"SELECT\"]);\r\nvar getBoundingBox = function (ref, transformPagePoint) {\r\n    var rect = ref.current.getBoundingClientRect();\r\n    var _a = transformPagePoint({\r\n        x: rect.left,\r\n        y: rect.top,\r\n    }), left = _a.x, top = _a.y;\r\n    var _b = transformPagePoint({\r\n        x: rect.width,\r\n        y: rect.height,\r\n    }), width = _b.x, height = _b.y;\r\n    return { left: left, top: top, width: width, height: height };\r\n};\r\nvar getCurrentOffset = function (point) {\r\n    return point ? point.get() : 0;\r\n};\r\n/**\r\n * Takes a parent Element and a draggable Element and returns pixel-based drag constraints.\r\n *\r\n * @param constraintsRef\r\n * @param draggableRef\r\n */\r\nvar calculateConstraintsFromDom = function (constraintsRef, draggableRef, point, transformPagePoint) {\r\n    invariant(constraintsRef.current !== null && draggableRef.current !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n    var parentBoundingBox = getBoundingBox(constraintsRef, transformPagePoint);\r\n    var draggableBoundingBox = getBoundingBox(draggableRef, transformPagePoint);\r\n    var left = parentBoundingBox.left -\r\n        draggableBoundingBox.left +\r\n        getCurrentOffset(point.x);\r\n    var top = parentBoundingBox.top -\r\n        draggableBoundingBox.top +\r\n        getCurrentOffset(point.y);\r\n    var right = parentBoundingBox.width - draggableBoundingBox.width + left;\r\n    var bottom = parentBoundingBox.height - draggableBoundingBox.height + top;\r\n    return { top: top, left: left, right: right, bottom: bottom };\r\n};\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\nvar getConstraints = function (axis, _a) {\r\n    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\r\n    if (axis === \"x\") {\r\n        return { min: left, max: right };\r\n    }\r\n    else {\r\n        return { min: top, max: bottom };\r\n    }\r\n};\r\nfunction applyConstraints(axis, value, constraints, dragElastic) {\r\n    var constrainedValue = value instanceof MotionValue ? value.get() : value;\r\n    if (!constraints) {\r\n        return constrainedValue;\r\n    }\r\n    var _a = getConstraints(axis, constraints), min = _a.min, max = _a.max;\r\n    if (min !== undefined && constrainedValue < min) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(min, constrainedValue, dragElastic)\r\n            : Math.max(min, constrainedValue);\r\n    }\r\n    else if (max !== undefined && constrainedValue > max) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(max, constrainedValue, dragElastic)\r\n            : Math.min(max, constrainedValue);\r\n    }\r\n    if (value instanceof MotionValue) {\r\n        value.set(constrainedValue);\r\n    }\r\n    return constrainedValue;\r\n}\r\nfunction applyOverdrag(origin, current, dragElastic) {\r\n    var dragFactor = typeof dragElastic === \"number\" ? dragElastic : 0.35;\r\n    return mix(origin, current, dragFactor);\r\n}\r\nfunction bothAxis(handler) {\r\n    return [handler(\"x\"), handler(\"y\")];\r\n}\r\n/**\r\n * A hook that allows an element to be dragged.\r\n *\r\n * @param param\r\n * @param ref\r\n * @param values\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useDrag(_a, ref, values, controls) {\r\n    var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? true : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, _dragValueX = _a._dragValueX, _dragValueY = _a._dragValueY, _dragTransitionControls = _a._dragTransitionControls, dragOriginX = _a.dragOriginX, dragOriginY = _a.dragOriginY, dragTransition = _a.dragTransition, onDirectionLock = _a.onDirectionLock, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onDragTransitionEnd = _a.onDragTransitionEnd;\r\n    // If `dragConstraints` is a React `ref`, we should resolve the constraints once the\r\n    // component has rendered.\r\n    var constraintsNeedResolution = isRefObject(dragConstraints);\r\n    // We create a mutable state using a ref as we want to keep track of certain data, even across renders,\r\n    // but we don't want to re-render as a result of them.\r\n    var dragStatus = useRef({\r\n        isDragging: false,\r\n        hasDragged: false,\r\n        currentDirection: null,\r\n        constraints: false,\r\n        handlers: {},\r\n    }).current;\r\n    // Load the callbacks into mutable state to ensure that even if we don't create a new\r\n    // gesture handler every render, we still reference the latest callbacks (which are almost certain to change per render)\r\n    var handlers = dragStatus.handlers;\r\n    handlers.onDragStart = onDragStart;\r\n    handlers.onDrag = onDrag;\r\n    handlers.onDragEnd = onDragEnd;\r\n    handlers.onDirectionLock = onDirectionLock;\r\n    handlers.onDragTransitionEnd = onDragTransitionEnd;\r\n    var point = useRef({}).current;\r\n    // Track origin\r\n    var defaultOriginX = useMotionValue(0);\r\n    var defaultOriginY = useMotionValue(0);\r\n    var origin = {\r\n        x: dragOriginX || defaultOriginX,\r\n        y: dragOriginY || defaultOriginY,\r\n    };\r\n    // This is a reference to the global drag gesture lock, ensuring only one component\r\n    // can \"capture\" the drag of one or both axes.\r\n    var openGlobalLock = useRef(null);\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    // If `dragConstraints` is a React `ref`, we need to track changes in its\r\n    // size and update the current draggable position relative to that.\r\n    var prevConstraintsBox = useRef({\r\n        width: 0,\r\n        height: 0,\r\n        x: 0,\r\n        y: 0,\r\n    }).current;\r\n    var scalePoint = function () {\r\n        if (!isRefObject(dragConstraints))\r\n            return;\r\n        var constraintsBox = getBoundingBox(dragConstraints, transformPagePoint);\r\n        var draggableBox = getBoundingBox(ref, transformPagePoint);\r\n        // Scale a point relative to the transformation of a constraints-providing element.\r\n        var scaleAxisPoint = function (axis, dimension) {\r\n            var pointToScale = point[axis];\r\n            if (!pointToScale)\r\n                return;\r\n            // Stop any current animations as they bug out if you resize during one\r\n            if (pointToScale.isAnimating()) {\r\n                pointToScale.stop();\r\n                recordBoxInfo();\r\n                return;\r\n            }\r\n            // If the previous dimension was `0` (default), set `scale` to `1` to prevent\r\n            // divide by zero errors.\r\n            var scale = prevConstraintsBox[dimension]\r\n                ? (constraintsBox[dimension] - draggableBox[dimension]) /\r\n                    prevConstraintsBox[dimension]\r\n                : 1;\r\n            pointToScale.set(prevConstraintsBox[axis] * scale);\r\n        };\r\n        scaleAxisPoint(\"x\", \"width\");\r\n        scaleAxisPoint(\"y\", \"height\");\r\n    };\r\n    useResize(dragConstraints, scalePoint);\r\n    // If our drag constraints are a potentially live bounding box, record its previously-calculated\r\n    // dimensions and the current x/y\r\n    var recordBoxInfo = function (constraints) {\r\n        if (constraints) {\r\n            var right = constraints.right, left = constraints.left, bottom = constraints.bottom, top_1 = constraints.top;\r\n            prevConstraintsBox.width = (right || 0) - (left || 0);\r\n            prevConstraintsBox.height = (bottom || 0) - (top_1 || 0);\r\n        }\r\n        if (point.x)\r\n            prevConstraintsBox.x = point.x.get();\r\n        if (point.y)\r\n            prevConstraintsBox.y = point.y.get();\r\n    };\r\n    var applyConstraintsToPoint = function (constraints) {\r\n        return bothAxis(function (axis) {\r\n            var axisPoint = point[axis];\r\n            axisPoint &&\r\n                !axisPoint.isAnimating() &&\r\n                applyConstraints(axis, axisPoint, constraints, 0);\r\n        });\r\n    };\r\n    // On mount, if our bounding box is a ref, we need to resolve the constraints\r\n    // and immediately apply them to our point.\r\n    useEffect(function () {\r\n        if (!constraintsNeedResolution)\r\n            return;\r\n        var constraints = calculateConstraintsFromDom(dragConstraints, ref, point, transformPagePoint);\r\n        applyConstraintsToPoint(constraints);\r\n        recordBoxInfo(constraints);\r\n    }, []);\r\n    // If `dragConstraints` is set to `false` or `Constraints`, set constraints immediately.\r\n    // Otherwise we'll resolve on mount.\r\n    dragStatus.constraints = constraintsNeedResolution\r\n        ? false\r\n        : dragConstraints;\r\n    // Get the `MotionValue` for both draggable axes, or create them if they don't already\r\n    // exist on this component.\r\n    bothAxis(function (axis) {\r\n        if (!shouldDrag(axis, drag, dragStatus.currentDirection))\r\n            return;\r\n        var defaultValue = axis === \"x\" ? _dragValueX : _dragValueY;\r\n        point[axis] = defaultValue || values.get(axis, 0);\r\n    });\r\n    // Apply constraints immediately, even before render, if our constraints are a plain object.\r\n    if (!dragStatus.isDragging &&\r\n        dragStatus.constraints &&\r\n        !constraintsNeedResolution) {\r\n        applyConstraintsToPoint(dragStatus.constraints);\r\n    }\r\n    // Add additional information to the `PanInfo` object before passing it to drag listeners.\r\n    function convertPanToDrag(info) {\r\n        return __assign({}, info, { point: {\r\n                x: point.x ? point.x.get() : 0,\r\n                y: point.y ? point.y.get() : 0,\r\n            } });\r\n    }\r\n    // This function will be used to update each axis point every frame.\r\n    function updatePoint(axis, offset) {\r\n        var axisPoint = point[axis];\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!shouldDrag(axis, drag, dragStatus.currentDirection) ||\r\n            !axisPoint) {\r\n            return;\r\n        }\r\n        var axisOrigin = origin[axis].get();\r\n        var current = applyConstraints(axis, origin[axis].get() + offset[axis], dragStatus.constraints, dragElastic);\r\n        if (current !== axisOrigin)\r\n            dragStatus.hasDragged = true;\r\n        axisPoint.set(current);\r\n    }\r\n    function onPanSessionStart(event) {\r\n        // Prevent browser-specific behaviours like text selection or Chrome's image dragging.\r\n        if (event.target &&\r\n            !allowDefaultPointerDown.has(event.target.tagName)) {\r\n            event.preventDefault();\r\n            // Make sure input elements loose focus when we prevent the default.\r\n            if (document.activeElement instanceof HTMLElement) {\r\n                document.activeElement.blur();\r\n            }\r\n        }\r\n        // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\r\n        // which has come out of the difficulty in us being able to do this once a scroll gesture\r\n        // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\r\n        // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\r\n        // trigger this once we've got a scroll direction determined. This approach sort-of worked\r\n        // but if the component was dragged too far in a single frame page scrolling would initiate.\r\n        blockViewportScroll();\r\n        // Stop any animations on both axis values immediately. This allows the user to throw and catch\r\n        // the component.\r\n        bothAxis(function (axis) {\r\n            var axisPoint = point[axis];\r\n            axisPoint && axisPoint.stop();\r\n        });\r\n    }\r\n    function onPanStart(event, info) {\r\n        dragStatus.isDragging = true;\r\n        dragStatus.hasDragged = false;\r\n        // Resolve the constraints again in case anything has changed in the meantime.\r\n        if (constraintsNeedResolution) {\r\n            dragStatus.constraints = calculateConstraintsFromDom(dragConstraints, ref, point, transformPagePoint);\r\n            applyConstraintsToPoint(dragStatus.constraints);\r\n        }\r\n        // Set point origin and stop any existing animations.\r\n        bothAxis(function (axis) {\r\n            var axisPoint = point[axis];\r\n            if (!axisPoint)\r\n                return;\r\n            origin[axis].set(axisPoint.get());\r\n            axisPoint.stop();\r\n        });\r\n        // Attempt to grab the global drag gesture lock.\r\n        if (!dragPropagation) {\r\n            if (openGlobalLock.current)\r\n                openGlobalLock.current();\r\n            openGlobalLock.current = getGlobalLock(drag);\r\n            if (!openGlobalLock.current) {\r\n                return;\r\n            }\r\n        }\r\n        dragStatus.currentDirection = null;\r\n        var onDragStart = handlers.onDragStart;\r\n        onDragStart && onDragStart(event, convertPanToDrag(info));\r\n    }\r\n    function onPan(event, info) {\r\n        // If we didn't successfully receive the gesture lock, early return.\r\n        if (!dragPropagation && !openGlobalLock.current) {\r\n            return;\r\n        }\r\n        var offset = info.offset;\r\n        // Attempt to detect drag direction if directionLock is true\r\n        if (dragDirectionLock && dragStatus.currentDirection === null) {\r\n            dragStatus.currentDirection = getCurrentDirection(offset);\r\n            // If we've successfully set a direction, notify listener\r\n            if (dragStatus.currentDirection !== null) {\r\n                var onDirectionLock_1 = handlers.onDirectionLock;\r\n                onDirectionLock_1 && onDirectionLock_1(dragStatus.currentDirection);\r\n            }\r\n            return;\r\n        }\r\n        updatePoint(\"x\", offset);\r\n        updatePoint(\"y\", offset);\r\n        var onDrag = handlers.onDrag;\r\n        onDrag && onDrag(event, convertPanToDrag(info));\r\n    }\r\n    function cancelDrag() {\r\n        unblockViewportScroll();\r\n        dragStatus.isDragging = false;\r\n        if (!dragPropagation && openGlobalLock.current) {\r\n            openGlobalLock.current();\r\n            openGlobalLock.current = null;\r\n        }\r\n    }\r\n    function animateDragEnd(velocity) {\r\n        var momentumAnimations = bothAxis(function (axis) {\r\n            var _a;\r\n            if (!shouldDrag(axis, drag, dragStatus.currentDirection)) {\r\n                return;\r\n            }\r\n            var transition = dragStatus.constraints\r\n                ? getConstraints(axis, dragStatus.constraints)\r\n                : {};\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            var bounceStiffness = dragElastic ? 200 : 1000000;\r\n            var bounceDamping = dragElastic ? 40 : 10000000;\r\n            var animationControls = _dragTransitionControls || controls;\r\n            return animationControls.start((_a = {},\r\n                _a[axis] = 0,\r\n                // TODO: It might be possible to allow `type` animations to be set as\r\n                // Popmotion animations as well as strings. Then people could define their own\r\n                // and it'd open another route for us to code-split.\r\n                _a.transition = __assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\r\n                    bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1 }, dragTransition, transition),\r\n                _a));\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        Promise.all(momentumAnimations).then(function () {\r\n            recordBoxInfo(dragStatus.constraints);\r\n            scalePoint();\r\n            var onDragTransitionEnd = handlers.onDragTransitionEnd;\r\n            onDragTransitionEnd && onDragTransitionEnd();\r\n        });\r\n    }\r\n    function onPanEnd(event, info) {\r\n        cancelDrag();\r\n        if (!dragStatus.hasDragged)\r\n            return;\r\n        // If we have either `dragMomentum` or `dragElastic`, initiate momentum and boundary spring animation for both axes.\r\n        if (dragMomentum || dragElastic) {\r\n            var velocity = info.velocity;\r\n            animateDragEnd(velocity);\r\n        }\r\n        else {\r\n            recordBoxInfo(dragStatus.constraints);\r\n        }\r\n        var onDragEnd = handlers.onDragEnd;\r\n        onDragEnd && onDragEnd(event, convertPanToDrag(info));\r\n    }\r\n    usePanGesture(drag ? { onPan: onPan, onPanStart: onPanStart, onPanEnd: onPanEnd, onPanSessionStart: onPanSessionStart } : {}, ref);\r\n    useUnmountEffect(function () { return dragStatus.isDragging && cancelDrag(); });\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold) {\r\n    if (lockThreshold === void 0) { lockThreshold = 10; }\r\n    var direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\n\nvar Drag = {\r\n    key: \"drag\",\r\n    shouldRender: function (props) { return !!props.drag; },\r\n    Component: makeHookComponent(function (_a) {\r\n        var innerRef = _a.innerRef, values = _a.values, controls = _a.controls, props = __rest(_a, [\"innerRef\", \"values\", \"controls\"]);\r\n        return useDrag(props, innerRef, values, controls);\r\n    }),\r\n};\n\nfunction isCSSVariable(value) {\r\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\r\n}\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\r\nfunction parseCSSVariable(current) {\r\n    var match = cssVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    var token = match[1], fallback = match[2];\r\n    return [token, fallback];\r\n}\r\nvar maxDepth = 4;\r\nfunction getVariableValue(current, element, depth) {\r\n    if (depth === void 0) { depth = 1; }\r\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\r\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        return resolved;\r\n    }\r\n    else if (isCSSVariable(fallback)) {\r\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\r\n        return getVariableValue(fallback, element, depth + 1);\r\n    }\r\n    else {\r\n        return fallback;\r\n    }\r\n}\r\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\r\nfunction resolveCSSVariables(values, ref, _a, transitionEnd) {\r\n    var target = __rest(_a, []);\r\n    var element = ref.current;\r\n    if (!(element instanceof HTMLElement))\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\r\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\r\n    if (transitionEnd) {\r\n        transitionEnd = __assign({}, transitionEnd);\r\n    }\r\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\r\n    values.forEach(function (value) {\r\n        var current = value.get();\r\n        if (!isCSSVariable(current))\r\n            return;\r\n        var resolved = getVariableValue(current, element);\r\n        if (resolved)\r\n            value.set(resolved);\r\n    });\r\n    // Cycle through every target property and resolve CSS variables. Currently\r\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\r\n    for (var key in target) {\r\n        var current = target[key];\r\n        if (!isCSSVariable(current))\r\n            continue;\r\n        var resolved = getVariableValue(current, element);\r\n        if (!resolved)\r\n            continue;\r\n        // Clone target if it hasn't already been\r\n        target[key] = resolved;\r\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\r\n        // CSS variable. This will ensure that after the animation the component will reflect\r\n        // changes in the value of the CSS variable.\r\n        if (transitionEnd && transitionEnd[key] === undefined) {\r\n            transitionEnd[key] = current;\r\n        }\r\n    }\r\n    return { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\r\n    var transform = _a.transform;\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        return getPosFromMatrix(matrix[1], pos2);\r\n    }\r\n}; };\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(values, elementStyler) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = values.get(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        elementStyler.render();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a) {\r\n        var width = _a.width;\r\n        return width;\r\n    },\r\n    height: function (_a) {\r\n        var height = _a.height;\r\n        return height;\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var height = _a.height;\r\n        var top = _b.top;\r\n        return parseFloat(top) + height;\r\n    },\r\n    right: function (_a, _b) {\r\n        var width = _a.width;\r\n        var left = _b.left;\r\n        return parseFloat(left) + width;\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, values, element, elementStyler, changedKeys) {\r\n    var originBbox = element.getBoundingClientRect();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\r\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        elementStyler.set(\"display\", target.display || \"block\");\r\n    }\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    elementStyler.render();\r\n    var targetBbox = element.getBoundingClientRect();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = values.get(key);\r\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (values, ref, target, transitionEnd) {\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var element = ref.current;\r\n    var elementStyler = styler(element);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = targetPositionalKeys.reduce(function (acc, key) {\r\n        var value = values.get(key);\r\n        if (!value)\r\n            return acc;\r\n        var from = value.get();\r\n        var to = target[key];\r\n        var fromType = getDimensionValueType(from);\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = getDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) &&\r\n                            isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(getDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = getDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues = removeNonTranslationalTransform(values, elementStyler);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                acc.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n        return acc;\r\n    }, []);\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, values, element, elementStyler, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var key = _a[0], value = _a[1];\r\n                values.get(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        elementStyler.render();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @param values\r\n * @param ref\r\n * @param target\r\n * @param transitionEnd\r\n * @internal\r\n */\r\nfunction unitConversion(values, ref, target, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(values, ref, target, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar parseDomVariant = function (values, ref) {\r\n    return function (target, transitionEnd) {\r\n        var resolved = resolveCSSVariables(values, ref, target, transitionEnd);\r\n        target = resolved.target;\r\n        transitionEnd = resolved.transitionEnd;\r\n        return unitConversion(values, ref, target, transitionEnd);\r\n    };\r\n};\n\nfunction useForceUpdate() {\r\n    var _a = useState(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\r\n    return useCallback(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\r\n        forcedRenderCount,\r\n    ]);\r\n}\n\nvar SyncLayoutContext = createContext(null);\r\n/**\r\n * When layout changes happen asynchronously to their instigating render (ie when exiting\r\n * children of `AnimatePresence` are removed), `SyncLayout` can wrap parent and sibling\r\n * components that need to animate as a result of this layout change.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = ({ isVisible }) => {\r\n *   return (\r\n *     <SyncLayout>\r\n *       <AnimatePresence>\r\n *         {isVisible && (\r\n *           <motion.div exit={{ opacity: 0 }} />\r\n *         )}\r\n *       </AnimatePresence>\r\n *       <motion.div positionTransition />\r\n *     </SyncLayout>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * The way this component works is by memoising a function and passing it down via context.\r\n * The function, when called, updates the local state, which is used to invalidate the\r\n * memoisation cache. A new function is called, performing a synced re-render of components\r\n * that are using the SyncLayoutContext.\r\n *\r\n * @internal\r\n */\r\nvar UnstableSyncLayout = function (_a) {\r\n    var children = _a.children;\r\n    var forceUpdate = useForceUpdate();\r\n    return (createElement(SyncLayoutContext.Provider, { value: forceUpdate }, children));\r\n};\n\nvar _a;\r\nvar StepName;\r\n(function (StepName) {\r\n    StepName[\"Prepare\"] = \"prepare\";\r\n    StepName[\"Read\"] = \"read\";\r\n    StepName[\"Render\"] = \"render\";\r\n})(StepName || (StepName = {}));\r\nvar stepOrder = [StepName.Prepare, StepName.Read, StepName.Render];\r\nvar jobs = stepOrder.reduce(function (acc, key) {\r\n    acc[key] = [];\r\n    return acc;\r\n}, {});\r\nvar jobsNeedProcessing = false;\r\nfunction flushCallbackList(list) {\r\n    var numJobs = list.length;\r\n    for (var i = 0; i < numJobs; i++) {\r\n        list[i]();\r\n    }\r\n    list.length = 0;\r\n}\r\nfunction flushAllJobs() {\r\n    if (!jobsNeedProcessing)\r\n        return;\r\n    flushCallbackList(jobs.prepare);\r\n    flushCallbackList(jobs.read);\r\n    flushCallbackList(jobs.render);\r\n    jobsNeedProcessing = false;\r\n}\r\n// Note: The approach of schedulng jobs during the render step is incompatible with concurrent mode\r\n// where multiple renders might happen without a DOM update. This would result in unneccessary batched\r\n// jobs. But this was already a problem with our previous approach to positionTransition.\r\n// Hopefully the React team offer a getSnapshotBeforeUpdate-esque hook and we can move to that.\r\nvar createUseSyncEffect = function (stepName) { return function (callback) {\r\n    if (!callback)\r\n        return;\r\n    jobsNeedProcessing = true;\r\n    jobs[stepName].push(callback);\r\n}; };\r\nvar layoutSync = (_a = {},\r\n    _a[StepName.Prepare] = createUseSyncEffect(StepName.Prepare),\r\n    _a[StepName.Read] = createUseSyncEffect(StepName.Read),\r\n    _a[StepName.Render] = createUseSyncEffect(StepName.Render),\r\n    _a);\r\n// TODO: If we ever make this a public hook, add a check within `createUseSyncEffect` that, in development mode,\r\n// adds a useEffect to check if there's any remaining jobs and throw an error that we must add the `useLayoutSync`\r\n// hook to every component that schedules a job.\r\nfunction useLayoutSync() {\r\n    return useLayoutEffect(flushAllJobs);\r\n}\n\nfunction isHTMLElement(element) {\r\n    return element instanceof HTMLElement;\r\n}\n\nvar defaultLayoutTransition = {\r\n    duration: 0.8,\r\n    ease: [0.45, 0.05, 0.19, 1.0],\r\n};\r\nvar defaultPositionTransition = underDampedSpring();\r\nfunction getDefaultLayoutTransition(positionOnly) {\r\n    return positionOnly ? defaultPositionTransition : defaultLayoutTransition;\r\n}\r\nfunction isResolver(transition) {\r\n    return typeof transition === \"function\";\r\n}\r\n// Find the center of a Layout definition. We do this to account for potential changes\r\n// in the top/left etc that are actually just as a result of width/height changes.\r\nfunction centerOf(_a) {\r\n    var top = _a.top, left = _a.left, width = _a.width, height = _a.height;\r\n    var right = left + width;\r\n    var bottom = top + height;\r\n    return {\r\n        x: (left + right) / 2,\r\n        y: (top + bottom) / 2,\r\n    };\r\n}\r\nfunction calcDelta(prev, next) {\r\n    var prevCenter = centerOf(prev);\r\n    var nextCenter = centerOf(next);\r\n    return {\r\n        x: prevCenter.x - nextCenter.x,\r\n        y: prevCenter.y - nextCenter.y,\r\n        width: prev.width - next.width,\r\n        height: prev.height - next.height,\r\n    };\r\n}\r\nvar offset = {\r\n    getLayout: function (_a) {\r\n        var offset = _a.offset;\r\n        return offset;\r\n    },\r\n    measure: function (element) {\r\n        var offsetLeft = element.offsetLeft, offsetTop = element.offsetTop, offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;\r\n        return {\r\n            left: offsetLeft,\r\n            top: offsetTop,\r\n            width: offsetWidth,\r\n            height: offsetHeight,\r\n        };\r\n    },\r\n};\r\nvar boundingBox = {\r\n    getLayout: function (_a) {\r\n        var boundingBox = _a.boundingBox;\r\n        return boundingBox;\r\n    },\r\n    measure: function (element) {\r\n        var _a = element.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\r\n        return { left: left, top: top, width: width, height: height };\r\n    },\r\n};\r\nfunction readPositionStyle(element) {\r\n    return window.getComputedStyle(element).position;\r\n}\r\nfunction getLayoutType(prev, next, positionOnly) {\r\n    return positionOnly && prev === next ? offset : boundingBox;\r\n}\r\nfunction isSizeKey(key) {\r\n    return key === \"width\" || key === \"height\";\r\n}\r\nfunction useLayoutAnimation(ref, values, controls, layoutTransition, positionOnly) {\r\n    if (positionOnly === void 0) { positionOnly = false; }\r\n    // Allow any parent SyncLayoutContext components to force-update this component\r\n    useContext(SyncLayoutContext);\r\n    var element = ref.current;\r\n    useLayoutSync();\r\n    // If we don't have a HTML element we can early return here. We've already called all the hooks.\r\n    if (!isHTMLElement(element))\r\n        return;\r\n    // Keep track of the position style prop. Ideally we'd compare offset as this is uneffected by\r\n    // the same transforms that we want to use to performantly animate the layout. But if position changes,\r\n    // for example between \"static\" and \"fixed\", we can no longer rely on the offset and need\r\n    // to use the visual bounding box.\r\n    var prevPosition = readPositionStyle(element);\r\n    var prev = {\r\n        offset: offset.measure(element),\r\n        boundingBox: boundingBox.measure(element),\r\n    };\r\n    // Keep track of any existing transforms so we can reapply them after measuring the target bounding box.\r\n    var transform = \"\";\r\n    var next;\r\n    var compare;\r\n    // We split the unsetting, read and reapplication of the `transform` style prop into\r\n    // different steps via useSyncEffect. Multiple components might all be doing the same\r\n    // thing and by splitting these jobs and flushing them in batches we prevent layout thrashing.\r\n    layoutSync.prepare(function () {\r\n        // Unset the transform of all layoutTransition components so we can accurately measure\r\n        // the target bounding box\r\n        transform = element.style.transform;\r\n        element.style.transform = \"\";\r\n    });\r\n    layoutSync.read(function () {\r\n        // Read the target VisualInfo of all layoutTransition components\r\n        next = {\r\n            offset: offset.measure(element),\r\n            boundingBox: boundingBox.measure(element),\r\n        };\r\n        var nextPosition = readPositionStyle(element);\r\n        compare = getLayoutType(prevPosition, nextPosition, positionOnly);\r\n    });\r\n    layoutSync.render(function () {\r\n        // Reverse the layout delta of all newly laid-out layoutTransition components into their\r\n        // prev visual state and then animate them into their new one using transforms.\r\n        var prevLayout = compare.getLayout(prev);\r\n        var nextLayout = compare.getLayout(next);\r\n        var delta = calcDelta(prevLayout, nextLayout);\r\n        var hasAnyChanged = delta.x || delta.y || delta.width || delta.height;\r\n        if (!hasAnyChanged) {\r\n            // If layout hasn't changed, reapply the transform and get out of here.\r\n            transform && (element.style.transform = transform);\r\n            return;\r\n        }\r\n        syncRenderSession.open();\r\n        var target = {};\r\n        var transition = {};\r\n        var transitionDefinition = isResolver(layoutTransition)\r\n            ? layoutTransition({ delta: delta })\r\n            : layoutTransition;\r\n        function makeTransition(layoutKey, transformKey, targetValue, visualOrigin) {\r\n            // If this dimension hasn't changed, early return\r\n            var deltaKey = isSizeKey(layoutKey) ? layoutKey : transformKey;\r\n            if (!delta[deltaKey])\r\n                return;\r\n            var baseTransition = typeof transitionDefinition === \"boolean\"\r\n                ? __assign({}, getDefaultLayoutTransition(positionOnly)) : transitionDefinition;\r\n            var value = values.get(transformKey, targetValue);\r\n            var velocity = value.getVelocity();\r\n            transition[transformKey] = baseTransition[transformKey]\r\n                ? __assign({}, baseTransition[transformKey]) : __assign({}, baseTransition);\r\n            if (transition[transformKey].velocity === undefined) {\r\n                transition[transformKey].velocity = velocity || 0;\r\n            }\r\n            // The target value of all transforms is the default value of that prop (ie x = 0, scaleX = 1)\r\n            // This is because we're inverting the layout change with `transform` and then animating to `transform: none`\r\n            target[transformKey] = targetValue;\r\n            var offsetToApply = !isSizeKey(layoutKey) && compare === offset ? value.get() : 0;\r\n            value.set(visualOrigin + offsetToApply);\r\n        }\r\n        makeTransition(\"left\", \"x\", 0, delta.x);\r\n        makeTransition(\"top\", \"y\", 0, delta.y);\r\n        if (!positionOnly) {\r\n            makeTransition(\"width\", \"scaleX\", 1, prev.boundingBox.width / next.boundingBox.width);\r\n            makeTransition(\"height\", \"scaleY\", 1, prev.boundingBox.height / next.boundingBox.height);\r\n        }\r\n        target.transition = transition;\r\n        // Only start the transition if `transitionDefinition` isn't `false`. Otherwise we want\r\n        // to leave the values in their newly-inverted state and let the user cope with the rest.\r\n        transitionDefinition && controls.start(target);\r\n        // Force a render to ensure there's no visual flickering\r\n        syncRenderSession.flush();\r\n    });\r\n}\r\nvar Layout = {\r\n    key: \"layout\",\r\n    shouldRender: function (_a) {\r\n        var positionTransition = _a.positionTransition, layoutTransition = _a.layoutTransition;\r\n        invariant(!(positionTransition && layoutTransition), \"Don't set both positionTransition and layoutTransition on the same component\");\r\n        return (typeof window !== \"undefined\" &&\r\n            !!(positionTransition || layoutTransition));\r\n    },\r\n    Component: makeHookComponent(function (_a) {\r\n        var innerRef = _a.innerRef, controls = _a.controls, values = _a.values, positionTransition = _a.positionTransition, layoutTransition = _a.layoutTransition;\r\n        useLayoutAnimation(innerRef, values, controls, layoutTransition || positionTransition, !!positionTransition);\r\n    }),\r\n};\n\n/**\r\n * A list of all valid MotionProps\r\n *\r\n * @internalremarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nvar validMotionProps = new Set([\r\n    \"initial\",\r\n    \"animate\",\r\n    \"exit\",\r\n    \"style\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"transformValues\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"static\",\r\n    \"positionTransition\",\r\n    \"layoutTransition\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"drag\",\r\n    \"dragConstraints\",\r\n    \"dragDirectionLock\",\r\n    \"dragElastic\",\r\n    \"dragMomentum\",\r\n    \"dragPropagation\",\r\n    \"dragTransition\",\r\n    \"_dragValueX\",\r\n    \"_dragValueY\",\r\n    \"_dragTransitionControls\",\r\n    \"dragOriginX\",\r\n    \"dragOriginY\",\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"onHoverEnd\",\r\n    \"onHoverStart\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return validMotionProps.has(key);\r\n}\n\nvar AnimatePropType;\r\n(function (AnimatePropType) {\r\n    AnimatePropType[\"Target\"] = \"Target\";\r\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\r\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\r\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\r\n    if (prev === null)\r\n        return false;\r\n    var prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (var i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\n\nvar hasUpdated = function (prev, next) {\r\n    return (next !== undefined &&\r\n        (Array.isArray(prev) && Array.isArray(next)\r\n            ? !shallowCompare(next, prev)\r\n            : prev !== next));\r\n};\r\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\r\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\r\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\r\n    return mergeTransitionEnd\r\n        ? __assign({}, target, transitionEnd)\r\n        : target;\r\n}\r\n/**\r\n * Handle the `animate` prop when its an object of values, ie:\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ opacity: 1 }} />\r\n * ```\r\n *\r\n * @internalremarks\r\n * It might be worth consolidating this with `use-variants`\r\n *\r\n * ```jsx\r\n * <motion.div animate=\"visible\" />\r\n * ```\r\n *\r\n * @param target\r\n * @param controls\r\n * @param values\r\n * @param transition\r\n *\r\n * @internal\r\n */\r\nfunction useAnimateProp(targetAndTransition, controls, values, defaultTransition) {\r\n    var isInitialRender = useRef(true);\r\n    var prevValues = useRef(null);\r\n    if (!prevValues.current) {\r\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\r\n    }\r\n    useEffect(function () {\r\n        var targetToAnimate = {};\r\n        // These are the values we're actually animating\r\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\r\n        // This is the target as it'll be once transitionEnd values are applied\r\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\r\n        // Detect which values have changed between renders\r\n        for (var key in animatingTarget) {\r\n            // This value should animate on mount if this value doesn't already exist (wasn't\r\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\r\n            var shouldAnimateOnMount = isInitialRender.current &&\r\n                (!values.has(key) ||\r\n                    values.get(key).get() !== finalTarget[key]);\r\n            // If this value has updated between renders or it's we're animating this value on mount,\r\n            // add it to the animate target.\r\n            var isValidValue = finalTarget[key] !== null;\r\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\r\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\r\n                targetToAnimate[key] = animatingTarget[key];\r\n            }\r\n        }\r\n        isInitialRender.current = false;\r\n        prevValues.current = __assign({}, prevValues.current, finalTarget);\r\n        if (Object.keys(targetToAnimate).length) {\r\n            controls.start(__assign({}, targetToAnimate, { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\r\n        }\r\n    }, [targetAndTransition]);\r\n}\n\nvar labelsToArray = function (label) {\r\n    if (!label) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(label)) {\r\n        return label;\r\n    }\r\n    return [label];\r\n};\r\nvar resolveVariantLabels = function (variant) {\r\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\r\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\r\n};\r\n/**\r\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\r\n * When values in this array change, React re-runs the dependency. However if the array\r\n * contains a variable number of items, React throws an error.\r\n */\r\nvar asDependencyList = function (list) { return [\r\n    list.join(\",\"),\r\n]; };\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\r\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\r\n};\r\n/**\r\n * Handle variants and the `animate` prop when its set as variant labels.\r\n *\r\n * @param initial - Initial variant(s)\r\n * @param animate - Variant(s) to animate to\r\n * @param inherit - `true` is inheriting animations from parent\r\n * @param controls - Animation controls\r\n *\r\n * @internal\r\n */\r\nfunction useVariants(initial, animate, inherit, controls) {\r\n    var targetVariants = resolveVariantLabels(animate);\r\n    var context = useContext(MotionContext);\r\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\r\n    var hasMounted = useRef(false);\r\n    useEffect(function () {\r\n        var shouldAnimate = false;\r\n        if (inherit) {\r\n            // If we're inheriting variant changes and the parent has already\r\n            // mounted when this component loads, we need to manually trigger\r\n            // this animation.\r\n            shouldAnimate = !!parentAlreadyMounted;\r\n            targetVariants = resolveVariantLabels(context.animate);\r\n        }\r\n        else {\r\n            shouldAnimate =\r\n                hasMounted.current ||\r\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\r\n        }\r\n        shouldAnimate && controls.start(targetVariants);\r\n        hasMounted.current = true;\r\n    }, asDependencyList(targetVariants));\r\n}\n\n/**\r\n * `useAnimationGroupSubscription` allows a component to subscribe to an\r\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\r\n *\r\n * @param animation\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useAnimationGroupSubscription(animation, controls) {\r\n    var unsubscribe = useMemo(function () { return animation.subscribe(controls); }, [\r\n        animation,\r\n    ]);\r\n    useEffect(function () { return function () {\r\n        unsubscribe && unsubscribe();\r\n    }; }, [unsubscribe]);\r\n}\n\nvar _a$1, _b;\r\nvar AnimatePropComponents = (_a$1 = {},\r\n    _a$1[AnimatePropType.Target] = makeHookComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls, values = _a.values, transition = _a.transition;\r\n        return useAnimateProp(animate, controls, values, transition);\r\n    }),\r\n    _a$1[AnimatePropType.VariantLabel] = makeHookComponent(function (_a) {\r\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\r\n        return useVariants(initial, animate, inherit, controls);\r\n    }),\r\n    _a$1[AnimatePropType.AnimationSubscription] = makeHookComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls;\r\n        return useAnimationGroupSubscription(animate, controls);\r\n    }),\r\n    _a$1);\r\nvar isVariantLabel$1 = function (prop) {\r\n    return Array.isArray(prop) || typeof prop === \"string\";\r\n};\r\nvar isAnimationSubscription = function (_a) {\r\n    var animate = _a.animate;\r\n    return animate instanceof AnimationControls;\r\n};\r\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\r\nvar animatePropTypeTests = (_b = {},\r\n    _b[AnimatePropType.Target] = function (props) {\r\n        return (props.animate !== undefined &&\r\n            !isVariantLabel$1(props.animate) &&\r\n            !isAnimationSubscription(props));\r\n    },\r\n    _b[AnimatePropType.VariantLabel] = function (props) {\r\n        return (props.variants !== undefined ||\r\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\r\n    },\r\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\r\n    _b);\r\nvar getAnimationComponent = function (props) {\r\n    var animatePropType = undefined;\r\n    for (var key in AnimatePropType) {\r\n        if (animatePropTypeTests[key](props)) {\r\n            animatePropType = key;\r\n        }\r\n    }\r\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\r\n};\n\nfunction stripMotionProps(props) {\r\n    var domProps = {};\r\n    for (var key in props) {\r\n        if (!isValidMotionProp(key)) {\r\n            domProps[key] = props[key];\r\n        }\r\n    }\r\n    return domProps;\r\n}\r\nvar buildSVGProps = function (values, style) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var props = buildSVGAttrs(motionValueStyles, undefined, undefined, undefined, undefined, false);\r\n    props.style = __assign({}, style, props.style);\r\n    return props;\r\n};\r\nvar functionalityComponents = [Layout, Drag, Gestures];\r\nvar numFunctionalityComponents = functionalityComponents.length;\r\n/**\r\n * Create a configuration for `motion` components that provides DOM-specific functionality.\r\n *\r\n * @internal\r\n */\r\nfunction createDomMotionConfig(Component) {\r\n    var isDOM = typeof Component === \"string\";\r\n    var isSVG = isDOM && svgElements.indexOf(Component) !== -1;\r\n    return {\r\n        renderComponent: function (ref, style, values, props, isStatic) {\r\n            var forwardProps = isDOM ? stripMotionProps(props) : props;\r\n            var staticVisualStyles = isSVG\r\n                ? buildSVGProps(values, style)\r\n                : { style: buildStyleAttr(values, style, isStatic) };\r\n            return createElement(Component, __assign({}, forwardProps, { ref: ref }, staticVisualStyles));\r\n        },\r\n        /**\r\n         * loadFunctionalityComponents gets used by the `motion` component\r\n         *\r\n         * Each functionality component gets provided the `ref`, animation controls and the `MotionValuesMap`\r\n         * generated for that component, as well as all the `props` passed to it by the user.\r\n         *\r\n         * The pattern used to determine whether to load and use each piece of functionality is\r\n         * consistent (should render? Then push component) and could be used to extend functionality.\r\n         *\r\n         * By exposing a mutable piece of memory via an API like `extendMotionComponent` we could\r\n         * allow users to add `FunctionalComponentDefinition`s. This would allow us to offer file size\r\n         * reductions by shipping an entry point that doesn't load gesture and drag functionality, and\r\n         * also offer a way for users to develop plugins/other functionality. Because these functionalities\r\n         * are loaded as components, we can look into using Suspense for this purpose.\r\n         *\r\n         * For user-defined functionality we'd need to allow\r\n         *  1) User-defined prop typing (extending `P`)\r\n         *  2) User-defined \"clean props\" function that removes their plugin's props before being passed to the DOM.\r\n         */\r\n        loadFunctionalityComponents: function (ref, values, props, controls, inherit) {\r\n            var activeComponents = [];\r\n            // TODO: Consolidate Animation functionality loading strategy with other functionality components\r\n            var Animation = getAnimationComponent(props);\r\n            if (Animation) {\r\n                activeComponents.push(createElement(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: inherit, values: values }));\r\n            }\r\n            for (var i = 0; i < numFunctionalityComponents; i++) {\r\n                var _a = functionalityComponents[i], shouldRender = _a.shouldRender, key = _a.key, Component_1 = _a.Component;\r\n                if (shouldRender(props)) {\r\n                    activeComponents.push(createElement(Component_1, __assign({ key: key }, props, { values: values, controls: controls, innerRef: ref })));\r\n                }\r\n            }\r\n            return activeComponents;\r\n        },\r\n        getValueControlsConfig: function (ref, values) {\r\n            return {\r\n                values: values,\r\n                readValueFromSource: function (key) {\r\n                    return styler(ref.current).get(key);\r\n                },\r\n                // TODO: This is a good second source of plugins. This function contains the CSS variable\r\n                // and unit conversion support. These functions share a common signature. We could make another\r\n                // API for adding these.\r\n                makeTargetAnimatable: parseDomVariant(values, ref),\r\n            };\r\n        },\r\n    };\r\n}\n\nvar htmlMotionComponents = htmlElements.reduce(function (acc, Component) {\r\n    var config = createDomMotionConfig(Component);\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(config);\r\n    return acc;\r\n}, {});\r\nvar svgMotionComponents = svgElements.reduce(function (acc, Component) {\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(createDomMotionConfig(Component));\r\n    return acc;\r\n}, {});\r\n/**\r\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\r\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\r\n *\r\n * @internalremarks\r\n *\r\n * I'd like to make it possible for these to be loaded \"on demand\" - to reduce bundle size by only\r\n * including HTML/SVG stylers, animation and/or gesture support when necessary.\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ x: 100 }} />\r\n *\r\n * <motion.p animate={{ height: 200 }} />\r\n *\r\n * <svg><motion.circle r={10} animate={{ r: 20 }} /></svg>\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar motion = __assign({ custom: function (Component) {\r\n        return createMotionComponent(createDomMotionConfig(Component));\r\n    } }, htmlMotionComponents, svgMotionComponents);\n\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n *\r\n * @internal\r\n */\r\nfunction unwrapMotionValue(value) {\r\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\r\n    return isCustomValue(unwrappedValue)\r\n        ? unwrappedValue.toValue()\r\n        : unwrappedValue;\r\n}\n\nvar isCustomValueType = function (v) {\r\n    return typeof v === \"object\" && v.mix;\r\n};\r\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\r\nfunction transform() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var useImmediate = !Array.isArray(args[0]);\r\n    var argOffset = useImmediate ? 0 : -1;\r\n    var inputValue = args[0 + argOffset];\r\n    var inputRange = args[1 + argOffset];\r\n    var outputRange = args[2 + argOffset];\r\n    var options = args[3 + argOffset];\r\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer(outputRange[0]) }, options));\r\n    return useImmediate ? interpolator(inputValue) : interpolator;\r\n}\n\nvar isTransformer = function (v) {\r\n    return typeof v === \"function\";\r\n};\r\nvar noop = function (v) { return v; };\r\nfunction useTransform(parent, customTransform, to, options) {\r\n    var value = useRef(null);\r\n    var comparitor = [parent];\r\n    var transformer = noop;\r\n    if (isTransformer(customTransform)) {\r\n        transformer = customTransform;\r\n    }\r\n    else if (Array.isArray(to)) {\r\n        var from = customTransform;\r\n        transformer = transform(from, to, options);\r\n        comparitor = [parent, from.join(\",\"), to.join(\",\")];\r\n    }\r\n    return useMemo(function () {\r\n        if (value.current)\r\n            value.current.destroy();\r\n        value.current = parent.addChild({ transformer: transformer });\r\n        return value.current;\r\n    }, comparitor);\r\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\r\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\r\n// to simply hide content at unreasonable scales.\r\nvar maxScale = 100000;\r\nvar invertScale = function (scale) { return (scale > 0.001 ? 1 / scale : maxScale); };\r\n/**\r\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\r\n * of their respective parent scales.\r\n *\r\n * This is useful for undoing the distortion of content when scaling a parent component.\r\n *\r\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\r\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\r\n * of those instead.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = () => {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <motion.div style={{ scaleX, scaleY }} />\r\n * }\r\n * ```\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * function MyComponent() {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useInvertedScale(scale) {\r\n    var parentScaleX = useMotionValue(1);\r\n    var parentScaleY = useMotionValue(1);\r\n    var values = useContext(MotionContext).values;\r\n    invariant(!!(scale || values), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\r\n    if (scale) {\r\n        parentScaleX = scale.scaleX || parentScaleX;\r\n        parentScaleY = scale.scaleY || parentScaleY;\r\n    }\r\n    else if (values) {\r\n        parentScaleX = values.get(\"scaleX\", 1);\r\n        parentScaleY = values.get(\"scaleY\", 1);\r\n    }\r\n    var scaleX = useTransform(parentScaleX, invertScale);\r\n    var scaleY = useTransform(parentScaleY, invertScale);\r\n    return { scaleX: scaleX, scaleY: scaleY };\r\n}\n\nfunction useOnChange(value, callback) {\r\n    useEffect(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\r\n}\n\n/**\r\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\r\n *\r\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\r\n * to another `MotionValue`.\r\n *\r\n * @remarks\r\n *\r\n * ```jsx\r\n * const x = useSpring(0, { stiffness: 300 })\r\n * const y = useSpring(x, { damping: 10 })\r\n * ```\r\n *\r\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\r\n * @param springConfig - Configuration options for the spring.\r\n * @returns `MotionValue`\r\n *\r\n * @public\r\n */\r\nfunction useSpring(source, config) {\r\n    if (config === void 0) { config = {}; }\r\n    var activeSpringAnimation = useRef(null);\r\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\r\n    useMemo(function () {\r\n        return value.attach(function (v, set) {\r\n            if (activeSpringAnimation.current) {\r\n                activeSpringAnimation.current.stop();\r\n            }\r\n            activeSpringAnimation.current = spring(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\r\n            return value.get();\r\n        });\r\n    }, Object.values(config));\r\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\r\n    return value;\r\n}\n\nvar scrollX = motionValue(0);\r\nvar scrollY = motionValue(0);\r\nvar scrollXProgress = motionValue(0);\r\nvar scrollYProgress = motionValue(0);\r\nvar setProgress = function (offset, maxOffset, value) {\r\n    value.set(!maxOffset || !offset ? 0 : offset / maxOffset);\r\n};\r\nvar hasEventListener = false;\r\nvar addScrollListener = function () {\r\n    hasEventListener = true;\r\n    if (typeof window === \"undefined\")\r\n        return;\r\n    var updateScrollValues = function () {\r\n        var xOffset = window.pageXOffset;\r\n        var yOffset = window.pageYOffset;\r\n        // Set absolute positions\r\n        scrollX.set(xOffset);\r\n        scrollY.set(yOffset);\r\n        // Set 0-1 progress\r\n        setProgress(xOffset, document.body.clientWidth - window.innerWidth, scrollXProgress);\r\n        setProgress(yOffset, document.body.clientHeight - window.innerHeight, scrollYProgress);\r\n    };\r\n    updateScrollValues();\r\n    window.addEventListener(\"resize\", updateScrollValues);\r\n    window.addEventListener(\"scroll\", updateScrollValues, { passive: true });\r\n};\r\nvar viewportMotionValues = {\r\n    scrollX: scrollX,\r\n    scrollY: scrollY,\r\n    scrollXProgress: scrollXProgress,\r\n    scrollYProgress: scrollYProgress,\r\n};\r\n/**\r\n * Provides `MotionValue`s that update when the viewport scrolls:\r\n *\r\n * - `scrollX`  Horizontal scroll distance in pixels.\r\n * - `scrollY`  Vertical scroll distance in pixels.\r\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\r\n *\r\n * **Note:** If the returned scroll `MotionValue`s don't seem to be updating,\r\n * double check if the `body` tag styles are set to `width: 100%; height: 100%` or\r\n * similar, as this can break accurate measurement of viewport scroll.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useViewportScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <Frame scaleX={scrollYProgress} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\r\n * }\r\n * ```\r\n *\r\n * @internalremarks\r\n * This isn't technically a hook yet, but in the future it might be nice\r\n * to accept refs to elements and add scroll listeners to those, which\r\n * may involve the use of lifecycle.\r\n *\r\n * @public\r\n */\r\nfunction useViewportScroll() {\r\n    if (!hasEventListener) {\r\n        addScrollListener();\r\n    }\r\n    return viewportMotionValues;\r\n}\n\n/**\r\n * Creates `AnimationControls`, which can be used to manually start, stop\r\n * and sequence animations on one or more components.\r\n *\r\n * The returned `AnimationControls` should be passed to the `animate` property\r\n * of the components you want to animate.\r\n *\r\n * These components can then be animated with the `start` method.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { Frame, useAnimation } from 'framer'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <Frame animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { motion, useAnimation } from 'framer-motion'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <motion.div animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @returns Animation controller with `start` and `stop` methods\r\n *\r\n * @public\r\n */\r\nfunction useAnimation() {\r\n    var animationControls = useConstant(function () { return new AnimationControls(); });\r\n    useEffect(function () {\r\n        animationControls.mount();\r\n        return function () { return animationControls.unmount(); };\r\n    }, []);\r\n    return animationControls;\r\n}\n\n/**\r\n * Experimental API.\r\n *\r\n * Makes an animated version of `useState`.\r\n *\r\n * @remarks\r\n *\r\n * When the returned state setter is called, values will be animated to their new target.\r\n *\r\n * This allows the animation of arbitrary React components.\r\n *\r\n * **Note:** When animating DOM components, it's always preferable to use the `animate` prop, as Framer\r\n * will bypass React's rendering cycle with one optimised for 60fps motion. This Hook is specifically\r\n * for animating props on arbitrary React components, or for animating text content.\r\n *\r\n * ```jsx\r\n * const [state, setState] = useAnimatedState({ percentage: 0 })\r\n *\r\n * return (\r\n *   <Graph\r\n *     percentage={state.percentage}\r\n *     onTap={() => setState({ percentage: 50 })}\r\n *   />\r\n * )\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * TODO:\r\n * - Make hook accept a typed version of Target that accepts any value (not just DOM values)\r\n * - Allow hook to accept single values. ie useAnimatedState(0)\r\n * - Allow providing MotionValues via initialState.\r\n *\r\n * @beta\r\n */\r\nfunction useAnimatedState(initialState) {\r\n    var _a = useState(initialState), animationState = _a[0], onUpdate = _a[1];\r\n    var config = useConstant(function () { return ({ onUpdate: onUpdate }); });\r\n    var values = useMotionValues(config);\r\n    var controls = useValueAnimationControls({\r\n        values: values,\r\n        readValueFromSource: function (key) { return animationState[key]; },\r\n    }, {}, false);\r\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\r\n        return controls.start(animationDefinition);\r\n    }; });\r\n    useEffect(function () {\r\n        values.mount();\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return [animationState, startAnimation];\r\n}\n\n/**\r\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { Frame, useCycle } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <Frame\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { motion, useCycle } from \"framer-motion\"\r\n *\r\n * export const MyComponent = () => {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <motion.div\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @param items - items to cycle through\r\n * @returns [currentState, cycleState]\r\n *\r\n * @public\r\n */\r\nfunction useCycle() {\r\n    var items = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        items[_i] = arguments[_i];\r\n    }\r\n    // TODO: After Framer X beta, remove this warning\r\n    warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\r\n    var index = useRef(0);\r\n    var _a = useState(items[index.current]), item = _a[0], setItem = _a[1];\r\n    return [\r\n        item,\r\n        function (next) {\r\n            index.current =\r\n                typeof next !== \"number\"\r\n                    ? wrap(0, items.length, index.current + 1)\r\n                    : next;\r\n            setItem(items[index.current]);\r\n        },\r\n    ];\r\n}\n\nvar PresenceChild = function (_a) {\r\n    var children = _a.children, exitProps = _a.exitProps;\r\n    var context = useContext(MotionContext);\r\n    // Create a new `value` in all instances to ensure `motion` children re-render\r\n    // and detect any layout changes that might have occurred.\r\n    context = exitProps ? __assign({}, context, { exitProps: exitProps }) : __assign({}, context);\r\n    return (createElement(MotionContext.Provider, { value: context }, children));\r\n};\r\nfunction getChildKey(child) {\r\n    return child.key || \"\";\r\n}\r\nfunction updateChildLookup(children, allChildren) {\r\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\r\n            if (seenChildren.has(key)) {\r\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\r\n            }\r\n            seenChildren.add(key);\r\n        }\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, function (child) {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * The `AnimatePresence` component enables the use of the `exit` prop to animate components\r\n * when they're removed from the component tree.\r\n *\r\n * When adding/removing more than a single child component, every component\r\n * **must** be given a unique `key` prop.\r\n *\r\n * You can propagate exit animations throughout a tree by using variants.\r\n *\r\n * @library\r\n *\r\n * You can use any component(s) within `AnimatePresence`, but the first `Frame` in each should\r\n * have an `exit` property defined.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * You can use any component(s) within `AnimatePresence`, but the first `motion` component in each should\r\n * have an `exit` property defined.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceUpdate function, or one from a parent context if it exists.\r\n    var localForceUpdate = useForceUpdate();\r\n    var contextForceUpdate = useContext(SyncLayoutContext);\r\n    var forceUpdate = contextForceUpdate || localForceUpdate;\r\n    var isInitialRender = useRef(true);\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = useRef(filteredChildren);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = useRef(new Map())\r\n        .current;\r\n    // A living record of all currently exiting components.\r\n    var exiting = useRef(new Set()).current;\r\n    updateChildLookup(filteredChildren, allChildren);\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    if (isInitialRender.current) {\r\n        isInitialRender.current = false;\r\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), exitProps: initial ? undefined : { initial: false } }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    var childrenToRender = filteredChildren.slice();\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n        else {\r\n            // In case this key has re-entered, remove from the exiting list\r\n            exiting.delete(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (child) { return child.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                forceUpdate();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        var exitProps = {\r\n            custom: custom,\r\n            isExiting: true,\r\n            onExitComplete: onExit,\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), exitProps: exitProps }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child) }, child));\r\n    });\r\n    presentChildren.current = childrenToRender;\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (createElement(Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\r\n};\n\nexport { AnimatePresence, AnimationControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, Point, UnstableSyncLayout, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, transform, unwrapMotionValue, useAnimatedState, useAnimation, useCycle, useDomEvent, useExternalRef, useGestures, useInvertedScale, useMotionValue, usePanGesture, useSpring, useTapGesture, useTransform, useViewportScroll };\n"],"sourceRoot":""}